SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _S7I0PC5EE
[CLASS] baseform
[CLASSLOC] basecontrols.vcx
[BASECLASS] form
[OBJNAME] advanced
[START PROPERTIES]

</VFPData>
<memberdata name="cfoxuserid" type="property" display="cFoxUserID" favorites="True"/>
<memberdata name="cfoxusername" type="property" display="cFoxUserName" favorites="True"/>
<memberdata name="cleanup" type="method" display="Cleanup"/>
<memberdata name="lpersistsizeposition" type="property" display="lPersistSizePosition" favorites="True"/>
<memberdata name="lrelease" type="property" display="lRelease"/>
<memberdata name="lsavesettings" type="property" display="lSaveSettings" favorites="True"/>
<memberdata name="oengine" type="property" display="oEngine"/>
<memberdata name="opersist" type="property" display="oPersist"/>
<memberdata name="refreshform" type="method" display="RefreshForm"/>
<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
<memberdata name="restoresettings" type="method" display="RestoreSettings" favorites="True"/>
<memberdata name="savesettings" type="method" display="SaveSettings" favorites="True"/>
BorderStyle = 2
Caption = "Advanced Export Options"
DoCreate = .T.
Height = 183
MaxButton = .F.
MinButton = .F.
Name = "advanced"
Width = 420
WindowType = 1
_memberdata =      975<VFPData>
lsavesettings = .F.
oengine = .NULL.
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
lparameters toExportOptions, ;
	toEngine
dodefault()
with Thisform
	.oEngine = toEngine

	* Enabled Advanced options based on Export options on calling page.
	.chkClustered.Enabled  = toExportOptions.chkIndexes.Value
	.chkDropTables.Enabled = toExportOptions.chkTableToView.Value
	.opgRemoteViews.BaseOptionButton1.Enabled = toExportOptions.chkTableToView.Value
	.opgRemoteViews.BaseOptionButton2.Enabled = toExportOptions.chkTableToView.Value
	.opgRemoteViews.BaseOptionButton3.Enabled = toExportOptions.chkTableToView.Value

	* Value Advanced option controls from OEngine
	.chkClustered.Value   = .oEngine.ExportClustered and .chkClustered.enabled 
	.chkDropTables.Value  = .oEngine.DropLocalTables and .chkDropTables.enabled
	.opgRemoteViews.Value = .oEngine.ViewPrefixOrSuffix
	.txtRemViewExt.Value  = .oEngine.ViewNameExtension
endwith

ENDPROC
PROCEDURE QueryUnload
Thisform.Cancel()
nodefault

ENDPROC
PROCEDURE cancel
Thisform.Hide()

ENDPROC
PROCEDURE releasemembers
This.oEngine = .NULL.

ENDPROC
PROCEDURE validated
LOCAL llRetval, lcMessageText, loControl

llRetval = .F.
lcMessageText = ""
loControl = Null

DO CASE
	* Make sure extension if supplied if chose Prefix
	CASE EMPTY(thisform.txtRemViewExt.value) And thisform.opgRemoteViews.Value = 1 ;
			And thisform.txtRemViewExt.enabled
		lcMessageText = VIEW_NAME_PREFIX_REQD_LOC
		loControl = thisform.txtRemViewExt
	* Make sure extension if supplied if chose Suffix
	CASE EMPTY(thisform.txtRemViewExt.value) And thisform.opgRemoteViews.Value = 2 ;
			And thisform.txtRemViewExt.enabled
		lcMessageText = "You must supply a suffix for the view name, or choose None."
		loControl = thisform.txtRemViewExt
	* Make sure Suffix is not _local if not dropping tables (that's the default renaming suffix)
	CASE thisform.chkDropTables.Value = .F. And thisform.opgRemoteViews.Value = 2 And ;
		lower(Alltrim(thisform.txtRemViewExt.value)) = "_local"
		lcMessageText = "_local is the default suffix the Upsizng Wizard uses when renaming local tables. " + ;
							"You must either change this suffix or choose to Drop Local Tables."
		loControl = thisform.txtRemViewExt
	OTHERWISE
		llRetval = .T.
		* Provide gentle warning about dropping local tables
		IF thisform.chkDropTables.Value = .T.
			Thisform.oEngine.Alert ("You have chosen to Drop Local Tables! " + ;
							"You should make sure you have a recent backup of the local database before completing the Wizard.", 48)
		ENDIF	
ENDCASE

IF !llRetval
	Thisform.oEngine.Alert (lcMessageText, 48)
	loControl.SetFocus()
ENDIF

RETURN llRetval
ENDPROC
PROCEDURE writechanges
with Thisform
	* Write Advanced options to OEngine properties
	.oEngine.ExportClustered    = .chkClustered.Value 
	.oEngine.DropLocalTables    = .chkDropTables.Value
	.oEngine.ViewPrefixOrSuffix = .opgRemoteViews.Value 
	.oEngine.ViewNameExtension  = .txtRemViewExt.Value
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
10[END RESERVED2]
[START RESERVED3]
*cancel Specifies if a CommandButton is the Cancel button.
*validated validate form controls
*writechanges write changes to OEngine properties
droptables Drop local tables after upsizing them?
oengine A reference to an UpsizeEngine object
pkeyclustered Make primary key a clustered index
remoteviewextension Remote view name extension.
remoteviewpxsx Remote view name prefix or suffix
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _S7I0PG9XA
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkClustered
[PARENT] advanced
[START PROPERTIES]
Alignment = 0
Caption = "Make primary key a \<clustered index"
Left = 17
Name = "chkClustered"
TabIndex = 2
Top = 30
ZOrderSet = 3
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _S7L0OIAMI
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkDropTables
[PARENT] advanced
[START PROPERTIES]
Alignment = 0
Caption = "\<Drop local tables"
Left = 17
Name = "chkDropTables"
TabIndex = 3
Top = 50
ZOrderSet = 7
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _S7I0PG9X9
[CLASS] basecommandbutton
[CLASSLOC] basecontrols.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdCancel
[PARENT] advanced
[START PROPERTIES]
Cancel = .T.
Caption = "Cancel"
Left = 340
Name = "cmdCancel"
TabIndex = 8
Top = 150
ZOrderSet = 2
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
ThisForm.Cancel()

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _S7I0PG9WZ
[CLASS] basecommandbutton
[CLASSLOC] basecontrols.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdOk
[PARENT] advanced
[START PROPERTIES]
Caption = "OK"
Default = .T.
Left = 340
Name = "cmdOk"
TabIndex = 7
Top = 122
ZOrderSet = 1
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
IF thisform.Validated()
	thisform.WriteChanges()
	thisform.hide()
ENDIF
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8M0WXBNU
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] lblDefaultRemoteViewName
[PARENT] advanced
[START PROPERTIES]
BackStyle = 1
Caption = " Default remote \<view name: "
Left = 16
Name = "lblDefaultRemoteViewName"
Style = 3
TabIndex = 4
Top = 85
ZOrderSet = 5
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _S8Z0IU2FO
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] lblOptions
[PARENT] advanced
[START PROPERTIES]
BackStyle = 1
Caption = " Options: "
Left = 16
Name = "lblOptions"
Style = 3
TabIndex = 1
Top = 10
ZOrderSet = 5
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8M0WXBNU
[CLASS] baseoptiongroup
[CLASSLOC] basecontrols.vcx
[BASECLASS] optiongroup
[OBJNAME] opgRemoteViews
[PARENT] advanced
[START PROPERTIES]
Baseoptionbutton3.Caption = "\<None (same as local table name)"
Baseoptionbutton3.Left = 7
Baseoptionbutton3.Name = "Baseoptionbutton3"
Baseoptionbutton3.Top = 50
BorderStyle = 1
ButtonCount = 3
Height = 82
Left = 10
Name = "opgRemoteViews"
TabIndex = 5
Top = 92
Value = 1
Width = 304
ZOrderSet = 4
baseoptionbutton1.Caption = "\<Prefix"
baseoptionbutton1.Left = 7
baseoptionbutton1.Name = "baseoptionbutton1"
baseoptionbutton1.Top = 15
baseoptionbutton1.Value = 1
baseoptionbutton2.Caption = "\<Suffix"
baseoptionbutton2.Left = 7
baseoptionbutton2.Name = "baseoptionbutton2"
baseoptionbutton2.Top = 33
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
This.Parent.txtRemViewExt.Refresh()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _S7L0O3XTZ
[CLASS] basetextbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] textbox
[OBJNAME] txtRemViewExt
[PARENT] advanced
[START PROPERTIES]
InputMask = "XXXXXXXX"
Left = 86
Name = "txtRemViewExt"
TabIndex = 6
Top = 118
Width = 113
ZOrderSet = 6
[END PROPERTIES]
[START METHODS]
PROCEDURE Refresh
This.Enabled = not (This.Parent.opgRemoteViews.Value = 3 or ;
	not This.Parent.opgRemoteViews.BaseOptionButton1.Enabled)

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _S7L0P904Q
[CLASS] baseshape
[CLASSLOC] basecontrols.vcx
[BASECLASS] shape
[OBJNAME] Wizshape1
[PARENT] advanced
[START PROPERTIES]
Height = 58
Left = 10
Name = "Wizshape1"
Style = 3
Top = 17
Width = 305
ZOrderSet = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] advanced
[START PROPERTIES]
Tahoma, 0, 8, 5, 13, 11, 21, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90X23EZ
[CLASS] basewizardcontainer
[CLASSLOC] basewizard.vcx
[BASECLASS] container
[OBJNAME] cconnstr
[START PROPERTIES]
</VFPData>
<memberdata name="checkdriverversion" type="method" display="CheckDriverVersion"/>
<memberdata name="checkpermissionsora" type="method" display="CheckPermissionsOra"/>
<memberdata name="checkpermissionssqs" type="method" display="CheckPermissionsSqs"/>
<memberdata name="clasterrormessage" type="property" display="cLastErrorMessage"/>
<memberdata name="coldconnstr" type="property" display="cOldConnStr"/>
<memberdata name="getallserverdb" type="method" display="GetAllServerDb"/>
<memberdata name="getallservers" type="method" display="GetAllServers"/>
<memberdata name="getconnstr" type="method" display="GetConnStr"/>
<memberdata name="getdbcconnections" type="method" display="GetDbcConnections"/>
<memberdata name="getdbname" type="method" display="GetDbName"/>
<memberdata name="getdsns" type="method" display="GetDsns"/>
<memberdata name="getservertype" type="method" display="GetServerType"/>
<memberdata name="logoff" type="method" display="Logoff"/>
<memberdata name="logon" type="method" display="Logon"/>
<memberdata name="nconnectionstrtype" type="property" display="nConnectionStrType"/>
<memberdata name="refreshcontrols" type="method" display="RefreshControls"/>
<memberdata name="servertype" type="method" display="ServerType"/>
<memberdata name="sql_connect" type="method" display="Sql_Connect"/>
Height = 343
Name = "cconnstr"
Width = 604
_memberdata =     1336<VFPData>
clasterrormessage = 
coldconnstr = 
nconnectionstrtype = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
This.RefreshControls()
This.opgODBCType.Value = This.opgODBCType.Value

ENDPROC
PROCEDURE checkdriverversion
LOCAL lnRetVal, lnODBCEnv, lnhdbc, lcVersion, lnBytes

#DEFINE SQL_DRIVER_VER			7
*Earliest possible SQL 95 driver version is "02.05.0085"
*Previous version is "02.00.1912"

*This routine returns true if the version is 2.05 or later

IF !Thisform.oEngine.ServerType == "SQL Server95" THEN
	RETURN .T.
ENDIF

lnODBCEnv=VAL(SYS(3053))
lcVersion=space(20)
lnBytes=0

declare short SQLGetInfo IN odbc32 Integer hdbc, Integer fInfoType, ;
	string @ lcVersion, Integer cbInfoValueMax, Integer @ lnBytes

lnHDBC=sqlgetprop(Thisform.oEngine.MasterConnHand,"ODBChdbc")

lnRetVal=SQLGetInfo(lnHDBC,SQL_DRIVER_VER,@lcVersion,50,@lnBytes)

IF VAL(LEFT(m.lcVersion,5))>=2.05
	RETURN .T.
ELSE
	WAIT CLEAR
	=MESSAGEBOX(NEED_SQL6DRVR_LOC,ICON_EXCLAMATION,TITLE_TEXT_LOC)
	RETURN .F.
ENDIF

ENDPROC
PROCEDURE checkpermissionsora
*Here checking to see the user can create tablespaces, tables, clusters,triggers and procs

LOCAL lcErrMsg, lcSQL, lnOldArea, lnRetVal, lnRetVal, ;
	 aPerm, lcCRLF, llRetVal, lcSQL
	
lcCRLF=CHR(10)+CHR(13)

*Set permissions to false, then flip them true as appropriate
with Thisform.oEngine
	.Perm_Table		=	.F.
	.Perm_AltTS		=	.F.
	.Perm_Sproc		=	.F.
	.Perm_CreaTS		=	.F.
	.Perm_Trigger	=	.F.
	.Perm_UnlimTS	=	.F.
	.Perm_Cluster	=	.F.
	.Perm_Index		=	.F.
endwith
*See if this is Oracle 6 or Oracle 7
*Oracle 6 doesn't allow comments in queries so this will fail
*if user connected to Oracle 6

IF Thisform.oEngine.ServerVer = 6.00 THEN
	=MESSAGEBOX(ORA_NOT_COOL_LOC, ICON_EXCLAMATION, TITLE_TEXT_LOC)
	RETURN .F.
ENDIF

* determine the system priviliges for curent user
	lcsql = "Select * from SESSION_PRIVS"
	IF Thisform.oEngine.ExecuteTempSPT(lcSQL) 
		SCAN
		DO CASE
			CASE Sqlresult.privilege = 'ALTER TABLESPACE'
				Thisform.oEngine.Perm_AltTS = .T.
			CASE Sqlresult.privilege = 'CREATE TABLESPACE'
				Thisform.oEngine.Perm_CreaTS = .T.
			CASE Sqlresult.privilege = 'UNLIMITED TABLESPACE'
				Thisform.oEngine.Perm_UnlimTS = .T.
			CASE Sqlresult.privilege = 'CREATE CLUSTER'
				Thisform.oEngine.Perm_Cluster = .T.
			CASE Sqlresult.privilege = 'CREATE PROCEDURE'
				Thisform.oEngine.Perm_Sproc = .T.
			CASE Sqlresult.privilege = 'CREATE TABLE'
				Thisform.oEngine.Perm_Table = .T.
			CASE Sqlresult.privilege = 'CREATE TRIGGER'
				Thisform.oEngine.Perm_Trigger = .T.
			CASE Sqlresult.privilege = 'CREATE ANY INDEX'
				Thisform.oEngine.Perm_Index = .T.

		ENDCASE
		ENDSCAN	
		ELSE
	=MESSAGEBOX(CANT_PERMISSION_LOC,ICON_EXCLAMATION,TITLE_TEXT_LOC)
	with Thisform.oEngine
		.Perm_Table		=	.T.
		.Perm_AltTS		=	.T.
		.Perm_Sproc		=	.T.
		.Perm_CreaTS		=	.T.
		.Perm_Trigger	=	.T.
		.Perm_UnlimTS	=	.T.
		.Perm_Cluster	=	.T.
		.Perm_Index		=	.T.
	endwith
	RETURN
	ENDIF	

lcErrMsg=""
IF !Thisform.oEngine.Perm_CreaTS
	lcErrMsg=CANT_CREATE_TABLESPACE_LOC
ENDIF

IF !Thisform.oEngine.Perm_AltTS
	IF !EMPTY(lcErrMsg)
		lcErrMsg= lcErrMsg + ", "
	ENDIF
	lcErrMsg=lcErrMsg+CANT_ALTER_TABLESPACE_LOC
ENDIF

IF !Thisform.oEngine.Perm_Table THEN
	IF !EMPTY(lcErrMsg)
		lcErrMsg= lcErrMsg + ", "
	ENDIF
	lcErrMsg=lcErrMsg+CANT_CREATE_OTABLE_LOC
ENDIF 
IF !Thisform.oEngine.Perm_UnlimTS
	IF !EMPTY(lcErrMsg)
		lcErrMsg= lcErrMsg + ", "
	ENDIF
	lcErrMsg=lcErrMsg + CANT_UNLIMITED_TS_LOC
ENDIF

IF !Thisform.oEngine.Perm_Cluster
	IF !EMPTY(lcErrMsg)
		lcErrMsg= lcErrMsg + ", "
	ENDIF
	lcErrMsg=lcErrMsg + CANT_CREATE_OCLUST_LOC
ENDIF

IF !Thisform.oEngine.Perm_Index 
	IF !EMPTY(lcErrMsg)
		lcErrMsg=lcErrMsg+ ", "
	ENDIF
	lcErrMsg=lcErrMsg+CANT_CREATE_ORAINDEX_LOC
ENDIF

IF !Thisform.oEngine.Perm_Trigger
	IF !EMPTY(lcErrMsg) 
		lcErrMsg=lcErrMsg+ ", "
	ENDIF
	lcErrMsg=lcErrMsg+CANT_CREATE_TRIGGER_LOC
ENDIF

IF !Thisform.oEngine.Perm_Sproc
	IF !EMPTY(lcErrMsg) 
		lcErrMsg=lcErrMsg+ ", "
	ENDIF
	lcErrMsg=lcErrMsg+CANT_CREATE_OPROC_LOC
ENDIF


IF !EMPTY(lcErrMsg) THEN
	lcErrMsg=LACKING_PERMS_ORA + lcErrMsg + "."
	=MESSAGEBOX(lcErrMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
ENDIF

ENDPROC
PROCEDURE checkpermissionssqs
*This method gets userid and username, checks to see if the
*user is 'sa'

LOCAL lnRetVal

*Use the master database
IF lower(rtrim(Thisform.oEngine.ServerDBName))<>"master" THEN
	IF !Thisform.oEngine.ExecuteTempSPT("use master") THEN
		*If the user can't use master
		*they can just try their luck creating stuff
		RETURN
	ENDIF
ENDIF

*Get user name and id
lcUserName=""
lnUserID=0
lnRetVal=Thisform.oEngine.SingleValueSPT("select USER_NAME()",@lcUserName,"Exp")
Thisform.oEngine.UserName=lcUserName
lnRetVal=Thisform.oEngine.SingleValueSPT("select USER_ID()",@lnUserID,"Exp")
Thisform.oEngine.UserID=lnUserID

*If the user is sa, they can create devices
Thisform.oEngine.Perm_Device=IIF(Thisform.oEngine.UserID=1,.T.,.F.)
ENDPROC
PROCEDURE getallserverdb
LOCAL lcConnectionStr, lcTemAlias as String
LOCAL lnConnectionHandle, lnOK, lnOldWorkArea as Integer


WITH This
	.cmbDatabases.Clear()
	lcConnectionStr = .Getconnstr()
	IF !EMPTY(lcConnectionStr)

		lnConnectionHandle = This.SQL_Connect(lcConnectionStr,1)
		
		IF lnConnectionHandle  > 0
			lcTemAlias = SYS(2015)
			lnOldWorkArea = SELECT()
			lnOK = SQLEXEC(lnConnectionHandle,"sp_databases",lcTemAlias)
			IF lnOK > 0
				SELECT(lcTemAlias)
				SCAN
					.cmbDatabases.AddItem(ALLTRIM(DataBase_Name))
				ENDSCAN
			ENDIF
			IF USED(lcTemAlias)
				USE IN (lcTemAlias)
			ENDIF
			SELECT(lnOldWorkArea)
			SQLDISCONNECT(lnConnectionHandle)
		ENDIF
	ENDIF
	.cmbDatabases.Requery()
ENDWITH
ENDPROC
PROCEDURE getallservers
LOCAL lServersString[1,1], lerrorString[1,1], Names_Data, get_ser

lServersString[1,1] = ""
lerrorString[1,1] = ""

Wait WINDOW "Retrieving SQL Server information" NOWAIT NoClear

get_ser = GetSQLServers(@lServersString, @lerrorString)
Names_Data = STRTRAN(lServersString, ',', Chr(13)+Chr(10))

WITH THIS.cmbServers as ComboBox
	.Clear()

	For i = 1 To Memlines(Names_Data)
		.AddListItem(ALLTRIM(Mline(Names_Data, i)))
	ENDFOR

	IF .ListCount > 0
		.ListIndex = 1
	ENDIF
ENDWITH

WAIT CLEAR
ENDPROC
PROCEDURE getconnstr
LOCAL lcConnectionString, lcConnectionName, lcDBCName, lcOldDatabase as String
LOCAL llUseDBCConnection as Logical
LOCAL loException as Exception
LOCAL lnErrorNo, lnODBCType as Integer

lcConnectionString = ""

WITH This
	llUseDBCConnection = (.opgConnection.Value = 1)
	
	IF llUseDBCConnection
	* Use cannection from database
		lcConnectionString = ALLTRIM(.cmbConnections.Value)
		.nConnectionstrtype = 1
	ELSE
	* Use ODBC
		.nConnectionstrtype = 2
		lnODBCType = .opgODBCType.Value
		DO CASE
			CASE lnODBCType = 1 && DSN
				IF !EMPTY(.cmbDSN.Value)
					lcConnectionString = "DSN=" + ALLTRIM(.cmbDSN.Value)
					IF !EMPTY(.txtDSNUserName.Value)
						lcConnectionString = lcConnectionString + ";UID=" + ALLTRIM(.txtDSNUserName.Value)
					ENDIF
					IF ! EMPTY(.txtDSNPassword.Value)
						lcConnectionString = lcConnectionString + ";PWD=" + ALLTRIM(.txtDSNPassword.Value)
					ENDIF
				ENDIF 
			CASE lnODBCType = 2 && Server
				IF !EMPTY(.cmbServers.DisplayValue)
					lcConnectionString = "DRIVER={SQL SERVER};SERVER=" + ALLTRIM(.cmbServers.DisplayValue)
					IF .chkUseTC.Value && Use Trusted Connection
						lcConnectionString = lcConnectionString + ";Trusted_Connection=YES"
					ELSE
						IF !EMPTY(.txtServerUID.Value)
							lcConnectionString = lcConnectionString + ";UID=" + ALLTRIM(.txtServerUID.Value)
						ENDIF
						IF !EMPTY(.txtServerPWD.Value)
							lcConnectionString = lcConnectionString + ";PWD=" + ALLTRIM(.txtServerPWD.Value)	
						ENDIF
					ENDIF
				ENDIF
			CASE lnODBCType = 3 && User Write Connection string
				lcConnectionString = ALLTRIM(.edtUserConnStr.Value)
		ENDCASE
	ENDIF
	.cOldconnstr = lcConnectionString
ENDWITH

RETURN lcConnectionString
ENDPROC
PROCEDURE getdbcconnections
LPARAMETERS tcDBCName

LOCAL lcOldDatabase, laDBCConnection[1,1] as String
LOCAL loException as Exception
LOCAL lnErrorNo, lnConnectionCount, lnConnIndex as Integer

This.cmbConnections.Clear()

IF !DBUSED(tcDBCName)
	lnErrorNo = 0
	TRY
		OPEN DATABASE (tcDBCName)
	CATCH TO loException
		lnErrorNo = loException.ErrorNo
	ENDTRY
	IF lnErrorNo > 0
		=MESSAGEBOX("Cannot open database " + lcDBCPathName,0 + 64,ThisForm.Caption)
		RETURN .f.
	ENDIF
ENDIF

IF DBUSED(tcDBCName)
	lcOldDatabase = SET("Database")
	SET DATABASE TO (tcDBCName)
	lnConnectionCount = 0
	lnConnectionCount = ADBOBJECTS(laDBCConnection,"CONNECTION")
	IF lnConnectionCount > 0
		FOR lnConnIndex = 1 TO lnConnectionCount
			This.cmbConnections.AddItem(laDBCConnection[lnConnIndex])
		ENDFOR
		This.cmbConnections.ListIndex = 1
	ELSE
		=MESSAGEBOX("There are no connections in the selected Database.",0 + 64,ThisForm.Caption)
	ENDIF
	SET DATABASE TO (lcOldDatabase)
ENDIF
ENDPROC
PROCEDURE getdbname
LOCAL lcSQL, lcDBName, llOne

	* only for SOL server (AT-12/10/95)
lcSQL="SELECT DB_NAME()"
lcDBName=""
Thisform.oEngine.SingleValueSPT(lcSQL, @lcDBName, "Exp", llOne)
	
RETURN lcDBName

ENDPROC
PROCEDURE getdsns
LOCAL lnDataSourcesNum, laDSN[1,1], kk

lnDataSourcesNum = 0

This.cmbDSN.Clear()
lnDataSourcesNum = AODBCDataSources(@laDSN)
IF lnDataSourcesNum > 0
	asort(laDSN, -1, -1, 0, 1)
	FOR kk = 1 TO lnDataSourcesNum
		This.cmbDSN.AddItem(laDSN[kk,1])
	ENDFOR
	This.cmbDSN.ListIndex = 1
ENDIF

RETURN lnDataSourcesNum
ENDPROC
PROCEDURE getservertype
local lcServerType, lnRetVal
lcServerType = ""

declare short SQLGetInfo IN odbc32 Integer hdbc,Integer fInfoType,String @cName,;
		Integer cNameMax, Integer @cbName

*Start ODBC
hdbc = sqlgetprop(Thisform.oEngine.MasterConnHand, "ODBChdbc")
		
*Do until all the data source names have been retrieved
cName = space(128)
cbName = 0

lnRetVal = sqlgetinfo(hdbc, SQL_DBMS_NAME, @cName, 128, @cbName)

IF lnRetVal = SQL_SUCCESS THEN		&&if no error occurred
	cName = UPPER(LEFT(cName, AT(CHR(0), cName)-1))
	lcServerType = this.ServerType(cName)
ENDIF
	
IF lcServerType <> IIF(Thisform.oEngine.SqlServer, SQL_SERVER, ORACLE_SERVER)
	lcMsg = STRTRAN(INVALID_SERVER_LOC, "|1", cName)
	=MESSAGEBOX(lcMsg, ICON_EXCLAMATION, TITLE_TEXT_LOC)
	RETURN .F.
ENDIF

Thisform.oEngine.CurrentServerType = lcServerType
Thisform.oEngine.ServerType = lcServerType

* get server version
cName = space(128)
cbName = 0

lnRetVal = sqlgetinfo(hdbc, SQL_DBMS_VER, @cName, 128, @cbName)
IF lnRetVal # SQL_SUCCESS 		&&if no error occurred
	RETURN
ENDIF

* parses the version string 'vv.MM.mmmm' and returns the value for 'vv.MM'
cName = LEFT(cName, AT(CHR(0), cName)-1)
	
* actual server version or 0
Thisform.oEngine.ServerVer = VAL(cName)

*See what version of SQL Server they're using
IF Thisform.oEngine.SqlServer
	DO CASE
	CASE Thisform.oEngine.ServerVer < 4
		*Old unsupported SQL Server
		=MESSAGEBOX(VERS_NOT_SUPPORTED_LOC,ICON_EXCLAMATION,TITLE_TEXT_LOC)
		RETURN .F.
	CASE Thisform.oEngine.ServerVer < 6
		*4.x is cool
		Thisform.oEngine.ServerType = "SQL Server"
	CASE Thisform.oEngine.ServerVer >= 6
		*New and improved SQL Server
		Thisform.oEngine.ServerType = "SQL Server95"	
	ENDCASE
ENDIF

ENDPROC
PROCEDURE logoff
local lcDataSourceName, ;
	lcDataSourceType, ;
	i, ;
	lnUserInput, ;
	lcConnection, ;
	lcExact

* If the user made device decisions, warn them that these will go. Otherwise,
* just do it.

if Thisform.oEngine.DeviceLogChosen or Thisform.oEngine.DeviceDBChosen or ;
	Thisform.oEngine.GridFilled
	lnUserInput = messagebox(DELETE_DEVICE_INFO_LOC, ICON_EXCLAMATION + ;
		YES_NO_BUTTONS, TITLE_TEXT_LOC)
else
	lnUserInput = USER_YES
endif

*Reset stuff if OK with user or nothing lost (no device decisions made)

IF lnUserInput=USER_YES
	Thisform.oEngine.DeviceCleanUp()
	Thisform.oEngine.GridFilled = .F.
	*Make sure we aren't getting tons of open connections if the user comes back and changes the datasource
	IF Thisform.oEngine.MasterConnHand<>0 THEN
		TRY
			SQLDISCONN(Thisform.oEngine.MasterConnHand)
		CATCH
		ENDTRY
		Thisform.oEngine.MasterConnHand=0
	ENDIF
	RETURN .T.
ELSE
	*Set the user's choice back and prevent move to next page
	this.ResetChoices
	RETURN .F.
ENDIF

ENDPROC
PROCEDURE logon
LOCAL lcPartialConnectString, lnDsIndex, lcDataSourceName, ;
	  lcUserName, lnUserID, lcServerType, lcExact, lcMsg, lcConnectDB
	
LOCAL lcConnStr

lcExact = SET('EXACT')
SET EXACT ON

WAIT CHECK_PERMS_LOC WINDOW NOWAIT

Thisform.oEngine.DataSourceName = ""

Thisform.oEngine.MasterConnHand = 0
lcConnStr = This.GetConnStr()
IF this.opGCONNECTION.Value = 1
	IF EMPTY(lcConnStr)
		=MESSAGEBOX("There are no connections in the selected Database.",0 + 64,ThisForm.Caption)
		RETURN .F.
	ENDIF
	Thisform.oEngine.UserConnection = lcConnStr
	Thisform.oEngine.MasterConnHand = This.SQL_Connect(lcConnStr, 0)
ELSE
	IF This.opGODBCTYPE.Value = 1 ;&& DSN
		And This.cmbDSN.ListCount > 0 and This.cmbDSN.ListIndex > 0

		Thisform.oEngine.DataSourceName = This.cmBDSN.Value
	ENDIF
	Thisform.oEngine.MasterConnHand = This.SQL_Connect(lcConnStr, 1)
ENDIF

IF !Thisform.oEngine.UserConnection=="" THEN
	Thisform.oEngine.PwdInDef=!EMPTY(DBGETPROP(Thisform.oEngine.UserConnection,"connection","password"))
ELSE
	Thisform.oEngine.PwdInDef=.F.
ENDIF

SET EXACT &lcExact

DO CASE
	CASE Thisform.oEngine.MasterConnHand = -1
		* connection failure
*!*			THISFORMSET.refreshsteps
		lcMsg = This.cLastErrorMessage
		=MESSAGEBOX(lcMsg, ICON_EXCLAMATION, TITLE_TEXT_LOC)
		WAIT CLEAR
		RETURN .F.

	CASE Thisform.oEngine.MasterConnHand = -2
		* invalid conn. handle (rare)
*!*			THISFORMSET.refreshsteps
		lcMsg = STRTRAN(SQLCONN_FAIL_LOC, "|1", lcDataSourceName)
		=MESSAGEBOX(lcMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
		Thisform.oEngine.DataSourceChosen  = .F.
		WAIT CLEAR
		RETURN .F.
ENDCASE

*Set properties of the connection in case the user has weird settings
Thisform.oEngine.ConnectString = SQLGETPROP(Thisform.oEngine.MasterConnHand,"connectstring")
Thisform.oEngine.SetConnProps()
*!*	this.getUserName

* check the actual server type (SQL_SERVER or ORACLE_SERVER) and get server version
lcServerType = Thisform.oEngine.ServerType	&& previous server type
IF !this.getServerType()
	WAIT CLEAR
	RETURN .F.
ENDIF

* If the user changes the server type, some recalculations need to be made
IF !lcServerType == Thisform.oEngine.ServerType THEN
	IF !Thisform.oEngine.EnumTablesTbl == "" THEN
		lnOldArea=SELECT()
		SELECT (Thisform.oEngine.EnumTablesTbl)
		REPLACE ALL FldsAnald with .F.
		* need new fields and mapping table
		Thisform.oEngine.EnumFieldsTbl = ""
		Thisform.oEngine.MappingTable = ""
		SELECT (lnOldArea)
	ENDIF
	Thisform.oEngine.AnalyzeFieldsRecalc=.T.
ENDIF

IF Thisform.oEngine.SqlServer
	*Figure out what database the user connected to
	Thisform.oEngine.ServerDBName=Thisform.oEngine.ParseConnectString(Thisform.oEngine.ConnectString,"database=")
	
	*See what db we're actually connected to; the database user expects 
	*to log into might no longer exist.  Or the user might have connected
	*with a DSN which doesn't specify a database
	lcConnectDB=this.GetDBName()
	*IF DSN doesn't specify database, see what we're connected to and
	*make that the target database
	IF Thisform.oEngine.ServerDBName==""
		Thisform.oEngine.ServerDBName=lcConnectDB
	ENDIF

	*If the connectdb and DSN-specified DB differ, that's fine if we're
	*not using a connection; a connection with a DB that doesn't exist is bad
	IF !LOWER(RTRIM(lcConnectDB))==LOWER(RTRIM(Thisform.oEngine.ServerDBName))
		IF Thisform.oEngine.UserConnection==""
			Thisform.oEngine.ServerDBName=lcConnectDB
		ELSE
			lcMsg=STRTRAN(DB_GONE_LOC,"|1",Thisform.oEngine.ServerDBName)
			=MESSAGEBOX(lcMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)	
			WAIT CLEAR
			RETURN .F.
		ENDIF		
	ENDIF
ELSE
	* Figure out what database the user connected to
	Thisform.oEngine.ServerDBName = Thisform.oEngine.ParseConnectString(Thisform.oEngine.ConnectString,"dbq=")
ENDIF

WAIT CHECK_PERMS_LOC WINDOW NOWAIT

IF Thisform.oEngine.SqlServer
	*User may have logged into a 1.x server
	IF !this.CheckPermissionsSQS() or !this.CheckDriverVersion()
		WAIT CLEAR
		RETURN .F.
	ENDIF
ELSE
	*User may have logged into an Oracle 6 server
	IF !this.CheckPermissionsORA()
		WAIT CLEAR
		RETURN .F.
	ENDIF
ENDIF
WAIT CLEAR

Thisform.oEngine.DataSourceChosen = .T.
ENDPROC
PROCEDURE refreshcontrols
LOCAL llDBCConnection as Logical
LOCAL lnODBCType as Integer

WITH This
	llDBCConnection = (.opgConnection.Value = 1)
	lnODBCType = .opgODBCType.Value
	
	* DBC Connections 
	.edtDatabase.Enabled = llDBCConnection
	.cmdGetDBC.Enabled = llDBCConnection
	.cmbConnections.Enabled = llDBCConnection
	.lblConnections.Enabled = llDBCConnection

	* ODBC
	.opgODBCType.Enabled = not llDBCConnection

	* DSN
	.cmbDSN.Enabled = (lnODBCType = 1) and !llDBCConnection
	.lblDSN.Enabled = .cmbDSN.Enabled
	.txtDSNPassword.Enabled = .cmbDSN.Enabled
	.lblDSNPassword.Enabled = .cmbDSN.Enabled
	.txtDSNUserName.Enabled = .cmbDSN.Enabled
	.lblDSNUserName.Enabled = .cmbDSN.Enabled

	* Sever
	.cmbServers.Enabled = (lnODBCType = 2) and !llDBCConnection
	.lblServers.Enabled = .cmbServers.Enabled
	.txtServerUID.Enabled = .cmbServers.Enabled and !.chkUseTC.Value
	.lblServerUID.Enabled = .cmbServers.Enabled and !.chkUseTC.Value
	.txtServerPWD.Enabled = .cmbServers.Enabled and !.chkUseTC.Value
	.lblServerPWD.Enabled = .cmbServers.Enabled and !.chkUseTC.Value
	.chkUseTC.Enabled = .cmbServers.Enabled
			
	* User Write connection string
	.edtUserConnStr.Enabled = (lnODBCType = 3)
ENDWITH
ENDPROC
PROCEDURE servertype
PARAMETER lcServerName
LOCAL lcServerType

DO CASE
CASE ATC("SQL Server",lcServerName) <> 0
	lcServerType = SQL_SERVER
CASE ATC("Oracle", lcServerName) <> 0
	lcServerType = ORACLE_SERVER
CASE ATC("Microsoft", lcServerName) <> 0
	lcServerType = MS_SERVER
OTHERWISE
	lcServerType = UNKNOWN_SERVER
ENDCASE

RETURN lcServerType
	

ENDPROC
PROCEDURE sql_connect
LPARAMETERS tcConnectionStr as String, tnConnectionStrType as Integer && 0 - SQLConnect, 1 - SQLStringConnect

LOCAL lnConnHand, lnConnStrType as Integer
LOCAL lOldDispLogin

lnConnHand = -1
lnConnStrType = 1
This.cLastErrorMessage = ""

IF VARTYPE(tcConnectionStr) # "C" OR EMPTY(tcConnectionStr)
	This.cLastErrorMessage = "Invalid connection string"
	RETURN lnConnHand
ENDIF

IF VARTYPE(tnConnectionStrType) = "N" AND BETWEEN(tnConnectionStrType,0,1)
	lnConnStrType = tnConnectionStrType 
ENDIF

lOldDispLogin = SQLGETPROP(0,"DispLogin")
SQLSETPROP(0,"DispLogin",3)

IF lnConnStrType = 1
	lnConnHand = SQLSTRINGCONNECT(tcConnectionStr)
ELSE
	lnConnHand = SQLCONNECT(tcConnectionStr)
ENDIF

IF lnConnHand = -1
	This.cLastErrorMessage = MESSAGE()
ENDIF

SQLSETPROP(0,"DispLogin",lOldDispLogin)

RETURN lnConnHand


ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
21[END RESERVED2]
[START RESERVED3]
*checkdriverversion 
*checkpermissionsora 
*checkpermissionssqs 
*getallserverdb 
*getallservers 
*getconnstr 
*getdbcconnections 
*getdbname 
*getdsns 
*getservertype 
*logoff 
*logon 
*refreshcontrols 
*servertype 
*sql_connect 
clasterrormessage
coldconnstr
nconnectionstrtype 1 - DBC Connection , 2 - Connection String
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\include\upsizing.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90ZD9JE
[CLASS] basewizardcheckbox
[CLASSLOC] basewizard.vcx
[BASECLASS] checkbox
[OBJNAME] chkUseTC
[PARENT] cconnstr
[START PROPERTIES]
Alignment = 0
Caption = "Use \<trusted connection"
ControlSource = "Thisform.lTrustedConnection"
Left = 314
Name = "chkUseTC"
TabIndex = 15
Top = 194
ZOrderSet = 21
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
dodefault()
This.Parent.Refreshcontrols()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardcombobox
[CLASSLOC] basewizard.vcx
[BASECLASS] combobox
[OBJNAME] cmbConnections
[PARENT] cconnstr
[START PROPERTIES]
ControlSource = "Thisform.cConnection"
Left = 90
Name = "cmbConnections"
Style = 2
TabIndex = 5
Top = 60
Width = 181
ZOrderSet = 4
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardcombobox
[CLASSLOC] basewizard.vcx
[BASECLASS] combobox
[OBJNAME] cmbDSN
[PARENT] cconnstr
[START PROPERTIES]
ControlSource = "Thisform.cDSN"
Left = 66
Name = "cmbDSN"
Style = 2
TabIndex = 8
Top = 135
Width = 173
ZOrderSet = 6
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardcombobox
[CLASSLOC] basewizard.vcx
[BASECLASS] combobox
[OBJNAME] cmbServers
[PARENT] cconnstr
[START PROPERTIES]
ControlSource = "Thisform.cServer"
Left = 110
Name = "cmbServers"
Style = 0
TabIndex = 14
Top = 190
Width = 173
ZOrderSet = 12
lrefreshstepsonchange = .F.
[END PROPERTIES]
[START METHODS]
PROCEDURE Valid
if not This.DisplayValue == This.Value
	This.AddListItem(This.DisplayValue)
	This.Value = This.DisplayValue
endif not This.DisplayValue == This.Value

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90XW5IP
[CLASS] basewizardcommandbutton
[CLASSLOC] basewizard.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdGetDBC
[PARENT] cconnstr
[START PROPERTIES]
Caption = "..."
Height = 22
Left = 500
Name = "cmdGetDBC"
TabIndex = 3
Top = 36
Width = 22
ZOrderSet = 3
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
LOCAL lcDBCPathName

lcDBCPathName = GETFILE("DBC")

IF !EMPTY(lcDBCPathName)
	This.Parent.edtDatabase.Value = lcDBCPathName
	This.Parent.GEtdbcconnections(lcDBCPathName)	
ENDIF
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardeditbox
[CLASSLOC] basewizard.vcx
[BASECLASS] editbox
[OBJNAME] edtDatabase
[PARENT] cconnstr
[START PROPERTIES]
ControlSource = "Thisform.cConnectionDatabase"
Height = 21
IntegralHeight = .F.
Left = 20
Name = "edtDatabase"
TabIndex = 2
Top = 36
Width = 481
ZOrderSet = 2
[END PROPERTIES]
[START METHODS]
PROCEDURE LostFocus
This.Value = chrtran(This.Value, chr(13) + chr(10), '')

ENDPROC
PROCEDURE Valid
IF !(This.Tag == UPPER(ALLTRIM(This.Value))) AND !EMPTY(This.Value)
	This.Parent.GEtdbcconnections(This.Value)
ENDIF
ENDPROC
PROCEDURE When
This.Tag = UPPER(ALLTRIM(This.Value))
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90YU523
[CLASS] basewizardeditbox
[CLASSLOC] basewizard.vcx
[BASECLASS] editbox
[OBJNAME] edtUserConnStr
[PARENT] cconnstr
[START PROPERTIES]
ControlSource = "Thisform.cConnString"
Height = 21
IntegralHeight = .F.
Left = 35
Name = "edtUserConnStr"
TabIndex = 22
Top = 295
Width = 559
ZOrderSet = 20
[END PROPERTIES]
[START METHODS]
PROCEDURE LostFocus
This.Value = chrtran(This.Value, chr(13) + chr(10), '')

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] lblConnections
[PARENT] cconnstr
[START PROPERTIES]
Caption = "\<Connection"
Left = 20
Name = "lblConnections"
TabIndex = 4
Top = 64
ZOrderSet = 5
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] lblDSN
[PARENT] cconnstr
[START PROPERTIES]
Caption = "\<DSN"
Left = 35
Name = "lblDSN"
TabIndex = 7
Top = 139
ZOrderSet = 7
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] lblDSNPassword
[PARENT] cconnstr
[START PROPERTIES]
Caption = "\<Password"
Left = 430
Name = "lblDSNPassword"
TabIndex = 11
Top = 139
ZOrderSet = 11
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] lblDSNUserName
[PARENT] cconnstr
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "\<User name"
Height = 15
Left = 250
Name = "lblDSNUserName"
TabIndex = 9
Top = 139
Width = 53
ZOrderSet = 10
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90YU51S
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] lblServerPWD
[PARENT] cconnstr
[START PROPERTIES]
Caption = "P\<assword"
Left = 35
Name = "lblServerPWD"
TabIndex = 18
Top = 244
ZOrderSet = 17
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] lblServers
[PARENT] cconnstr
[START PROPERTIES]
Caption = "\<Server name"
Left = 35
Name = "lblServers"
TabIndex = 13
Top = 194
ZOrderSet = 13
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90YU51R
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] lblServerUID
[PARENT] cconnstr
[START PROPERTIES]
Caption = "Us\<er name"
Left = 35
Name = "lblServerUID"
TabIndex = 16
Top = 219
ZOrderSet = 16
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90XW5IC
[CLASS] basewizardoptiongroup
[CLASSLOC] basewizard.vcx
[BASECLASS] optiongroup
[OBJNAME] opgConnection
[PARENT] cconnstr
[START PROPERTIES]
ButtonCount = 2
ControlSource = "Thisform.nConnectionType"
Height = 356
Left = -5
Name = "opgConnection"
TabIndex = 1
Top = 12
Value = 2
Width = 610
ZOrderSet = 0
baseoptionbutton1.Caption = "Use database connect\<ion"
baseoptionbutton1.Left = 5
baseoptionbutton1.Name = "baseoptionbutton1"
baseoptionbutton1.Top = 5
baseoptionbutton1.Value = 0
baseoptionbutton2.Caption = "\<ODBC"
baseoptionbutton2.Left = 5
baseoptionbutton2.Name = "baseoptionbutton2"
baseoptionbutton2.Top = 80
baseoptionbutton2.Value = 1
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
dodefault()

This.Parent.RefreshControls()

* For Chooce ODBC connection for first time
IF This.Value = 2 AND This.Parent.opgODBCType.Value = 1 AND This.Parent.cmbDSN.ListIndex = 0
	This.Parent.GEtdsns()
ENDIF
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90YIZA6
[CLASS] basewizardoptiongroup
[CLASSLOC] basewizard.vcx
[BASECLASS] optiongroup
[OBJNAME] opgODBCType
[PARENT] cconnstr
[START PROPERTIES]
Baseoptionbutton3.Caption = "Use connection st\<ring"
Baseoptionbutton3.Left = 5
Baseoptionbutton3.Name = "Baseoptionbutton3"
Baseoptionbutton3.Top = 164
ButtonCount = 3
ControlSource = "Thisform.nODBCType"
Height = 219
Left = 10
Name = "opgODBCType"
TabIndex = 6
Top = 111
Value = 1
Width = 588
ZOrderSet = 1
baseoptionbutton1.Caption = "Use DS\<N"
baseoptionbutton1.Left = 5
baseoptionbutton1.Name = "baseoptionbutton1"
baseoptionbutton1.Top = 4
baseoptionbutton1.Value = 1
baseoptionbutton2.Caption = "\<Generate SQL connection string"
baseoptionbutton2.Left = 5
baseoptionbutton2.Name = "baseoptionbutton2"
baseoptionbutton2.Top = 59
baseoptionbutton2.Value = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
dodefault()
DO CASE 
	CASE This.Value = 1 AND This.Parent.cmbDSN.ListCount = 0
		This.Parent.Getdsns()
	CASE This.Value =2 AND This.Parent.cmbServers.ListCount = 0
		This.Parent.Getallservers()
ENDCASE
This.Parent.REfreshcontrols()
ENDPROC
PROCEDURE ProgrammaticChange
This.InteractiveChange()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardtextbox
[CLASSLOC] basewizard.vcx
[BASECLASS] textbox
[OBJNAME] txtDSNPassword
[PARENT] cconnstr
[START PROPERTIES]
ControlSource = "Thisform.cDSNPassword"
Left = 487
Name = "txtDSNPassword"
PasswordChar = "*"
TabIndex = 12
Top = 135
Width = 109
ZOrderSet = 9
lrefreshstepsonchange = .F.
[END PROPERTIES]
[START METHODS]
PROCEDURE LostFocus
This.Value = chrtran(This.Value, chr(13) + chr(10), '')

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basewizardtextbox
[CLASSLOC] basewizard.vcx
[BASECLASS] textbox
[OBJNAME] txtDSNUserName
[PARENT] cconnstr
[START PROPERTIES]
ControlSource = "Thisform.cDSNUserName"
Left = 309
Name = "txtDSNUserName"
TabIndex = 10
Top = 135
Width = 109
ZOrderSet = 8
lrefreshstepsonchange = .F.
[END PROPERTIES]
[START METHODS]
PROCEDURE LostFocus
This.Value = chrtran(This.Value, chr(13) + chr(10), '')

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90YU51I
[CLASS] basewizardtextbox
[CLASSLOC] basewizard.vcx
[BASECLASS] textbox
[OBJNAME] txtServerPWD
[PARENT] cconnstr
[START PROPERTIES]
ControlSource = "Thisform.cServerPassword"
Left = 110
Name = "txtServerPWD"
PasswordChar = "*"
TabIndex = 19
Top = 240
Width = 173
ZOrderSet = 15
lrefreshstepsonchange = .F.
[END PROPERTIES]
[START METHODS]
PROCEDURE LostFocus
This.Value = chrtran(This.Value, chr(13) + chr(10), '')

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90YU51H
[CLASS] basewizardtextbox
[CLASSLOC] basewizard.vcx
[BASECLASS] textbox
[OBJNAME] txtServerUID
[PARENT] cconnstr
[START PROPERTIES]
ControlSource = "Thisform.cServerUserName"
Left = 110
Name = "txtServerUID"
TabIndex = 17
Top = 215
Width = 173
ZOrderSet = 14
[END PROPERTIES]
[START METHODS]
PROCEDURE LostFocus
This.Value = chrtran(This.Value, chr(13) + chr(10), '')

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] cconnstr
[START PROPERTIES]
Tahoma, 0, 8, 5, 13, 11, 21, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0LF7NE
[CLASS] basecontainer
[CLASSLOC] basecontrols.vcx
[BASECLASS] container
[OBJNAME] cfieldtypemap
[START PROPERTIES]
BackStyle = 0
BorderWidth = 0
Height = 270
Name = "cfieldtypemap"
Width = 423
crecordsource = 
[END PROPERTIES]
[START METHODS]
PROCEDURE crecordsource_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method

LOCAL lcEnumTablesTbl, lcAlias, lcEnumfields, lnOldArea, ;
	lcBigString,i, lnWidth

LOCAL lcFilterExpr as String

THIS.cRecordsource = m.vNewVal
IF EMPTY(THIS.cRecordsource)
	This.grdTypeMap.RecordSource = ""
	RETURN 
ENDIF

PRIVATE aTempArray, aTimeStamp[2]
lnOldArea=SELECT()
lcEnumTablesTbl = RTRIM(Thisform.oEngine.EnumTablesTbl)

lcAlias = vNewVal

EXTERNAL ARRAY ATABLESTOEXPORT

*Refresh the table combo box if appropriate
IF Thisform.oEngine.TableCboRecalc THEN
	*set datasource of combobox
	SELECT TblName FROM &lcEnumTablesTbl WHERE Export=.T. AND Type = "T";
		INTO ARRAY aTablesToExport
ENDIF


WITH This
	*Refresh the table combo box if appropriate
	IF Thisform.oEngine.AnalyzeFieldsRecalc=.T. THEN
		Thisform.oEngine.AnalyzeFields
		IF Thisform.oEngine.GridFilled=.T. THEN
			.grdTypeMap.refresh()
		ENDIF
	ENDIF

	*The interactive change event of the data type combo
	*relies on having RI and index information
	IF Thisform.oEngine.GetRiInfoRecalc THEN
		Thisform.oEngine.GetRIInfo()
		*(This routine calls the index analysis proc)
	ENDIF

	If !Thisform.oEngine.GridFilled THEN
		*Set number of columns and sizes based on server type
		lnWidth = .grdTypeMap.Width - sysmetric(5) - sysmetric(3) * 2
		IF Thisform.oEngine.ServerType="Oracle" OR RTRIM(Thisform.oEngine.ServerType)=="SQL Server95" THEN
			.grdTypeMap.grcType.width      = lnWidth * 0.19
			.grdTypeMap.grcRmtType.width   = lnWidth * 0.20
			.grdTypeMap.grcRmtLength.width = lnWidth * 0.12
			.grdTypeMap.grcRmtPrec.width   = lnWidth * 0.12
			.grdTypeMap.grcFldName.width   = lnWidth - .grdTypeMap.grcType.width - ;
				.grdTypeMap.grcRmtType.width - .grdTypeMap.grcRmtLength.width - ;
				.grdTypeMap.grcRmtPrec.width - .grdTypeMap.grcRmtNull.Width - 2
			.grdTypeMap.grcRmtPrec.visible=.T.
			.grdTypeMap.grcRmtPrec.enabled=.T.
		ELSE
			.grdTypeMap.grcType.width      = lnWidth * 0.23
			.grdTypeMap.grcRmtType.width   = lnWidth * 0.24
			.grdTypeMap.grcRmtLength.width = lnWidth * 0.16
			.grdTypeMap.grcFldName.width   = lnWidth - .grdTypeMap.grcType.width - ;
				.grdTypeMap.grcRmtType.width - .grdTypeMap.grcRmtLength.width - ;
				.grdTypeMap.grcRmtNull.Width - 2
			.grdTypeMap.grcRmtPrec.width=0
			.grdTypeMap.grcRmtPrec.visible=.F.
			.grdTypeMap.grcRmtPrec.enabled=.F.
		ENDIF

		IF Thisform.oEngine.MappingTable=="" THEN
			lcAlias=Thisform.oEngine.UniqueCursorName("UserType")
			lcEnumfields=RTRIM(Thisform.oEngine.EnumFieldsTbl)
			USE &lcEnumFields AGAIN IN 0 ALIAS &lcAlias
			SELECT (lnOldArea)
			Thisform.oEngine.MappingTable=lcAlias
		ELSE
			lcAlias=RTRIM(Thisform.oEngine.MappingTable)
		ENDIF
		
		IF Thisform.oEngine.TableCboRecalc
			SELECT (Thisform.oEngine.MappingTable)
			Thisform.oEngine.FiltCond=aTablesToExport[1]
			SET FILTER TO RTRIM(TblName)==RTRIM(Thisform.oEngine.FiltCond)
			SELECT (lnOldArea)
			Thisform.oEngine.TableCboRecalc=.F.
		ENDIF
		
		.grdTypeMap.RecordSource=lcAlias
		.grdTypeMap.grcFldName.ControlSource=lcalias + ".Fldname"
		.grdTypeMap.grcType.ControlSource=lcAlias + ".Combotype"
		.grdTypeMap.grcRmtType.ControlSource=lcalias + ".RmtType"
		.grdTypeMap.grcRmtLength.ControlSource=lcalias + ".RmtLength"
		.grdTypeMap.grcRmtLength.CurrentControl="txtLength"
		.grdTypeMap.grcRmtNull.ControlSource = lcAlias  + ".RmtNull"
		IF Thisform.oEngine.ServerType="Oracle" OR Thisform.oEngine.ServerType=="SQL Server95" THEN
			.grdTypeMap.grcRmtPrec.ControlSource=lcalias + ".RmtPrec"
			.grdTypeMap.grcRmtPrec.CurrentControl="txtPrecision"
		ENDIF
		
		
		Thisform.oEngine.GridFilled=.T.
		llCboRecalc=.T.

		*Generate an array for each FoxPro datatype
		Thisform.oEngine.CreateTypeArrays
		.grdTypeMap.grcRmtType.CurrentControl="cboDataTypes"
		.grdTypeMap.grcRmtType.cboDataTypes.GotFocus
		
	ENDIF


	*Make sure read/write status of length and precision fields is right
	SELECT(.grdTypeMap.RecordSource)
	lcFilterExpr = "Upper(ALLTRIM(" + .grdTypeMap.RecordSource + ".TblName)) == UPPER(ALLTRIM(" + lcEnumTablesTbl + ".TblName))"
	if eof(lcEnumTablesTbl)
		go top in (lcEnumTablesTbl)
	endif eof(lcEnumTablesTbl)
	SET FILTER TO &lcFilterExpr
	LOCATE
	
	.grdTypeMap.Refresh()
	.grdTypeMap.AfterRowColChange()
ENDWITH

Select(lnOldArea)

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
13[END RESERVED2]
[START RESERVED3]
*crecordsource_assign 
crecordsource
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\include\upsizing.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0V2TKW
[CLASS] basecommandbutton
[CLASSLOC] basecontrols.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdReset
[PARENT] cfieldtypemap
[START PROPERTIES]
Caption = "\<Default"
Left = 330
Name = "cmdReset"
TabIndex = 6
Top = 24
Width = 73
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
LOCAL lcTableName as String

lcTableName=RTRIM(EVALUATE(ALLTRIM(Thisform.oEngine.EnumTablesTbl) + ".TblName"))

Thisform.oEngine.DefaultMapping(lcTableName)

this.parent.grdTypeMap.refresh()

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0LHRG6
[CLASS] basegrid
[CLASSLOC] basecontrols.vcx
[BASECLASS] grid
[OBJNAME] grdTypeMap
[PARENT] cfieldtypemap
[START PROPERTIES]
AllowHeaderSizing = .F.
AllowRowSizing = .F.
Column1.FontName = "Tahoma"
Column1.FontSize = 8
Column1.Name = "grcFldName"
Column1.ReadOnly = .T.
Column1.Width = 122
Column2.FontName = "Tahoma"
Column2.FontSize = 8
Column2.Name = "grcType"
Column2.ReadOnly = .T.
Column2.Width = 74
Column3.FontName = "Tahoma"
Column3.FontSize = 8
Column3.Name = "grcRmtType"
Column3.Width = 78
Column4.Alignment = 1
Column4.FontName = "Tahoma"
Column4.FontSize = 8
Column4.Name = "grcRmtLength"
Column4.Width = 47
Column5.FontName = "Tahoma"
Column5.FontSize = 8
Column5.Name = "grcRmtPrec"
Column5.Width = 47
Column6.Alignment = 2
Column6.FontName = "Tahoma"
Column6.Name = "grcRmtNull"
Column6.Sparse = .F.
Column6.Width = 23
ColumnCount = 6
DeleteMark = .F.
Height = 212
HighlightStyle = 2
Name = "grdTypeMap"
RecordMark = .F.
ScrollBars = 2
SplitBar = .F.
TabIndex = 5
Top = 50
Width = 419
[END PROPERTIES]
[START METHODS]
PROCEDURE AfterRowColChange
PARAMETERS nColIndex
*If the user changes rows, the readonly property of the
*length and possibly precision columns may need to be changed

IF Thisform.oEngine.OldRow<>this.Activerow THEN
	LOCAL lcMappingTable, lcRmtType, lcLocalType, lnOldArea
	
	lcMappingTable=Thisform.oEngine.MappingTable
	lcRmtType=RTRIM(&lcMappingTable..RmtType)
	lcLocalType=RTRIM(&lcMappingTable..DataType)
	lnOldArea=SELECT()
	SELECT TypeMap	
	LOCATE FOR RTRIM(RemoteType)==lcRmtType ;
		AND RTRIM(LocalType)==lcLocalType ;
		AND Server=RTRIM(Thisform.oEngine.ServerType)
	this.grcRmtLength.Enabled=TypeMap.VarLength
	this.grcRmtPrec.Enabled=TypeMap.HasPrec

	this.grcRmtLength.Readonly=!TypeMap.VarLength
	this.grcRmtPrec.Readonly=!TypeMap.HasPrec
	SELECT(lnOldArea)
ENDIF

Thisform.oEngine.OldRow=this.ActiveRow

ENDPROC
PROCEDURE Init
* the grid picks up the current alias as rowsource
* if it is an upsizable table open SHARED, it gets closed and reopened EXCLUSIVE and
* this disables the column objects in the grid control
this.recordsource = ""
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0LHRIL
[CLASS] header
[BASECLASS] header
[OBJNAME] Header1
[PARENT] cfieldtypemap.grdTypeMap.grcFldName
[START PROPERTIES]
Caption = " Field name"
FontName = "Tahoma"
FontSize = 8
Name = "Header1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0LHRJN
[CLASS] header
[BASECLASS] header
[OBJNAME] Header1
[PARENT] cfieldtypemap.grdTypeMap.grcRmtLength
[START PROPERTIES]
Alignment = 1
Caption = "Width "
FontName = "Tahoma"
FontSize = 8
Name = "Header1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0LHRJP
[CLASS] basetextbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] textbox
[OBJNAME] txtLength
[PARENT] cfieldtypemap.grdTypeMap.grcRmtLength
[START PROPERTIES]
Alignment = 1
Name = "txtLength"
TabIndex = 1
[END PROPERTIES]
[START METHODS]
PROCEDURE Valid
LOCAL lnOldArea, lcRmtType

IF this.value<0 THEN
	RETURN .F.
ENDIF


lnOldArea=SELECT()
SELECT (Thisform.oEngine.MappingTable)
lcRmtType=RmtType
SELECT(lnOldArea)

*make sure value entered isn't too big
IF Thisform.oEngine.ServerType="Oracle" THEN
	
	#IF SUPPORT_ORACLE
		DO CASE
			CASE lcRmtType=="varchar2"
				IF this.value > 2000 OR this.value <= 0 THEN
					RETURN .F.
				ENDIF

			CASE lcRmtType=="char"
				IF this.value>255 OR this.value<=0 THEN
					RETURN .F.
				ENDIF
				
			CASE lcRmtType=="number"
				IF this.value>38 OR this.value<=0 THEN
					RETURN .F.
				ENDIF
			
			CASE lcRmtType=="raw"
				IF this.value > 255 OR this.value <= 0 THEN
					RETURN .F.
				ENDIF
				
		ENDCASE
	#ENDIF
		
ELSE
	DO CASE
	
		CASE lcRmtType=="numeric" OR lcRmtType=="decimal"
			IF this.value>38 OR this.value<=0 THEN
				RETURN .F.
			ENDIF
			
		OTHERWISE
			*char, varchar, binary, and varbinary all have a limit of 255
			IF this.value>255 ;
				OR this.value<0 ;
				OR (this.value=0 AND this.enabled) THEN
				RETURN .F.
			ENDIF
			
	ENDCASE
	
ENDIF

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HE0RQ0QG
[CLASS] header
[BASECLASS] header
[OBJNAME] Header1
[PARENT] cfieldtypemap.grdTypeMap.grcRmtNull
[START PROPERTIES]
Caption = " Null"
FontName = "Tahoma"
FontSize = 8
Name = "Header1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HE0RQ0QH
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] Check1
[PARENT] cfieldtypemap.grdTypeMap.grcRmtNull
[START PROPERTIES]
Alignment = 0
Caption = ""
Centered = .T.
Height = 17
Left = 7
Name = "Check1"
Top = 21
Width = 60
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0LHRJX
[CLASS] header
[BASECLASS] header
[OBJNAME] Header1
[PARENT] cfieldtypemap.grdTypeMap.grcRmtPrec
[START PROPERTIES]
Caption = " Precision"
FontName = "Tahoma"
FontSize = 8
Name = "Header1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0LHRJZ
[CLASS] basetextbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] textbox
[OBJNAME] txtPrecision
[PARENT] cfieldtypemap.grdTypeMap.grcRmtPrec
[START PROPERTIES]
Name = "txtPrecision"
TabIndex = 1
Visible = .T.
[END PROPERTIES]
[START METHODS]
PROCEDURE Valid
IF Thisform.oEngine.ServerType="Oracle" THEN
	#IF SUPPORT_ORACLE
		if this.value > 127 or this.value < -84 then
			return .f.
		endif
	#ENDIF
ELSE
	if this.value > 38 or this.value < 0 then
		return .f.
	endif
ENDIF
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0LHRIP
[CLASS] header
[BASECLASS] header
[OBJNAME] Header1
[PARENT] cfieldtypemap.grdTypeMap.grcRmtType
[START PROPERTIES]
Caption = " Server type"
FontName = "Tahoma"
FontSize = 8
Name = "Header1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0LHRIR
[CLASS] basecombobox
[CLASSLOC] basecontrols.vcx
[BASECLASS] combobox
[OBJNAME] cboDataTypes
[PARENT] cfieldtypemap.grdTypeMap.grcRmtType
[START PROPERTIES]
BorderStyle = 0
Margin = 2
Name = "cboDataTypes"
RowSourceType = 5
SpecialEffect = 1
TabIndex = 1
[END PROPERTIES]
[START METHODS]
PROCEDURE GotFocus
LOCAL lcMappingTable
lcMappingTable=Thisform.oEngine.MappingTable
this.rowsource="Thisform.oEngine." + rtrim(&lcMappingTable..DataType)
Thisform.oEngine.OldType=this.value

ENDPROC
PROCEDURE InteractiveChange
*When user changes data type, need to supply default
*length and (sometimes) precision

LOCAL lcMappingTable, lnLength, lnPrecision, lnOldArea, ;
	llCantIndex, lcRmtType, lnUserChoice, llInIndex, llUndo, ;
	aIndexNames, aRelatedTables, lcTableName, ;
	lcFieldName, lcRmtFieldname, llTwoLongs, lcOtherLong

lcMappingTable=Thisform.oEngine.MappingTable
lnOldArea=SELECT()
SELECT &lcMappingTable
lcRmtType=RTRIM(this.value)

IF Thisform.oEngine.ServerType="Oracle" THEN
	#IF SUPPORT_ORACLE
		DO CASE
			CASE lcRmtType=="varchar2"
				IF &lcMappingTable..DataType="M" THEN
					lnLength=2000
				ELSE
					lnLength=&lcMappingTable..Length
				ENDIF
				lnPrecision=0

			CASE lcRmtType=="char"
				IF &lcMappingTable..DataType="M" THEN
					lnLength=255
				ELSE
					lnLength=&lcMappingTable..Length
				ENDIF
				lnPrecision=0
				
			CASE lcRmtType=="number"
				*If local type is money, stick in different default values
				*otherwise use the length and precision of the local type
				IF &lcMappingTable..DataType="Y" THEN
					lnLength=19
					lnPrecision=4
				ELSE
					IF &lcMappingTable..DataType = "I" THEN
						lnLength = 11
						lnPrecision = 0
					ELSE
						lnLength=&lcMappingTable..Length
						lnPrecision=&lcMappingTable..Precision
					ENDIF
				ENDIF
			
			CASE lcRmtType=="raw"
				lnLength=255
				lnPrecision=0
				llCantIndex=.T.
				
			OTHERWISE
				*Case of long, date, and long raw
				lnLength=0
				lnPrecision=0
				IF lcRmtType=="LONG RAW" THEN
					llCantIndex=.T.
				ENDIF
			
		ENDCASE
	#ENDIF
	
ELSE

	DO CASE
		*
		*SQL 4.x datatypes
		*
		CASE lcRmtType=="varchar" OR ;
			lcRmtType=="char"
			IF &lcMappingTable..DataType="M" ;
				OR &lcMappingTable..DataType="G" THEN
				lnLength=255
			ELSE
				lnLength=&lcMappingTable..Length
			ENDIF
			lnPrecision=0

			
		CASE lcRmtType=="binary" OR ;
			lcRmtType=="varbinary"
				lnLength=255
				lnPrecision=0
		*
		*SQL '95 datatype
		*
		CASE lcRmtType=="numeric" OR ;
			lcRmtType=="decimal"
				lnLength=&lcMappingTable..Length
				lnPrecision=&lcMappingTable..Precision
			
		OTHERWISE
			lnLength=0
			IF lcRmtType=="bit" OR lcRmtType=="text" OR lcRmtType="image" THEN
				llCantIndex=.T.
			ENDIF
			lnLength=0
			lnPrecision=0
		
			
	ENDCASE

ENDIF

lcTableName=RTRIM(TblName)
lcFieldName=RTRIM(FldName)
lcRmtFieldname=RTRIM(RmtFldName)

*See if field is in any indexes
IF llCantIndex THEN
	DIMENSION aIndexNames[1]
	llInIndex=Thisform.oEngine.InIndex(@aIndexNames,lcFieldName,lcTableName)
ENDIF
		
*See if field is a primary or foreign key
llInKey=Thisform.oEngine.InKey(lcRmtFieldname, lcTableName)

#IF SUPPORT_ORACLE
	*See if there is already a field using the long data type
	IF RTRIM(lcRmtType)=="long" OR RTRIM(lcRmtType)=="long raw" THEN
		llTwoLongs=Thisform.oEngine.TwoLongs(lcTableName, lcFieldName, @lcOtherLong)
	ENDIF
#ENDIF
		
DO CASE

	#IF SUPPORT_ORACLE
		*Don't allow two fields of type Long or Long Raw
		CASE llTwoLongs
			lcMsg=STRTRAN(TWO_LONGS_WRONG_LOC,'|1',RTRIM(lcOtherLong))
			=MESSAGEBOX(lcMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
			llUndo=.T.
	#ENDIF

	*If the field is a key field and now unindexable, don't allow the change
	CASE llInKey AND llCantIndex
		lcMsg=STRTRAN(NO_NO_LOC,"|1",RTRIM(&lcMappingTable..FldName))
		lcMsg=STRTRAN(lcMsg,"|2",RTRIM(this.value))
		=MESSAGEBOX(lcMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
		llUndo=.T.

	*If the field is in a key but indexable, warn user to change other fields too
	CASE llInKey AND !llCantIndex
		lcMsg=STRTRAN(CASCADE_TYPE_CHANGE_LOC,"|1",RTRIM(FldName))
		=MESSAGEBOX(lcMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)

	*If the field is not a key field but is an index, warn user
	CASE (llCantIndex AND llInIndex) AND !llInKey
		lcMsg=STRTRAN(IN_INDEX_LOC,"|1",RTRIM(FldName))
		lcMsg=STRTRAN(lcMsg,"|2",RTRIM(this.value))
		lnUserChoice=MESSAGEBOX(lcMsg,ICON_EXCLAMATION+YES_NO_BUTTONS,TITLE_TEXT_LOC)
		IF lnUserChoice=DONT_INDEX THEN
			*Mark indexes as not to be created
			Thisform.oEngine.DontIndex(lcFieldName,lcTableName)
		ELSE
			llUndo=.T.
		ENDIF
		
ENDCASE

IF llUndo THEN
	this.value=Thisform.oEngine.OldType
ELSE
	REPLACE &lcMappingTable..RmtLength with lnLength, ;
		&lcMappingTable..RmtPrec with lnPrecision
	Thisform.oEngine.OldType=this.value

	*Now set readonly property of length and precision columns of the grid
	*Force recalc
	Thisform.oEngine.OldRow=this.parent.parent.ActiveRow + 1
	this.parent.parent.AfterRowColChange
ENDIF

SELECT(lnOldArea)

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HB0LHRIO
[CLASS] header
[BASECLASS] header
[OBJNAME] Header1
[PARENT] cfieldtypemap.grdTypeMap.grcType
[START PROPERTIES]
Caption = " FoxPro type"
FontName = "Tahoma"
FontSize = 8
Name = "Header1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] cfieldtypemap
[START PROPERTIES]
Tahoma, 0, 8, 5, 13, 11, 21, 2, 0
Tahoma, 0, 9, 5, 14, 12, 23, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R7204KDVS
[CLASS] basewizardcontainer
[CLASSLOC] basewizard.vcx
[BASECLASS] container
[OBJNAME] choosesourcedb
[START PROPERTIES]
BackColor = 192,192,192
BackStyle = 0
BorderWidth = 0
Height = 134
Name = "choosesourcedb"
TabIndex = 1
Width = 264
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
* Fill the listbox with available databases.

This.SelfFill()

* Bind to the SetSourceDatabase method of the form.

bindevent(Thisform, 'SetSourceDatabase', This, 'SelfFill', 1)

ENDPROC
PROCEDURE createdbarray
LOCAL i, aTempArray, lnGoodDBs, lnOpenDBs, lnOldArea, llNotExclusible
dimension This.aOpenDatabases[1,2]
dimension aTempArray[1,2]

This.aOpenDatabases = .F.
llNotExclusible = .F.
*Throw out any databases that are not or can't be opened exclusively
lnOpenDBs = adatabase(aTempArray)
lnGoodDBs = 0
lnOldArea = SELECT()
IF lnOpenDBs <> 0 
	FOR i = 1 to ALEN(aTempArray,1)
		SELECT 0
		if left(aTempArray[i,1], 6) <> 'UPSIZE'
			USE(aTempArray[i,2]) AGAIN
			IF ISEXCLUSIVE() THEN
				lnGoodDBs = lnGoodDBs+1
				IF lnGoodDBs > 1 THEN
					DIMENSION This.aOpenDatabases[ALEN(This.aOpenDatabases,1)+1,2]
				ENDIF
				This.aOpenDatabases[lnGoodDBs,1]=LOWER(aTempArray[i,1])
				This.aOpenDatabases[lnGoodDBs,2]=aTempArray[i,2]
			ELSE
				SET DATABASE TO aTempArray(i,1)
				CLOSE DATABASES
				OPEN DATABASE aTempArray(i,2) EXCLUSIVE
				lnGoodDBs=lnGoodDBs+1
				IF lnGoodDBs > 1 THEN
					DIMENSION This.aOpenDatabases[ALEN(This.aOpenDatabases,1)+1,2]
				ENDIF
				This.aOpenDatabases[lnGoodDBs,1]=LOWER(aTempArray[i,1])
				This.aOpenDatabases[lnGoodDBs,2]=aTempArray[i,2]
			ENDIF
			USE	
		endif left(aTempArray[i,1], 6) <> 'UPSIZE'
	NEXT i
ENDIF

IF lnGoodDBs=0 THEN
	This.aOpenDatabases[1,1]="<No database open>"
	this.lstList.enabled = .F.
ELSE
	this.lstList.enabled = .T.
ENDIF
SELECT (lnOldArea)
IF llNotExclusible
	=MESSAGEBOX("Databases which are not opened exclusively will not be available for upsizing.", 48,ThisForm.Caption)
ENDIF
ENDPROC
PROCEDURE exclusonly


ENDPROC
PROCEDURE reallychangesourcedb
LOCAL lnElement, lnSelectedDB, i, llReallyChange

* Changing the source database impacts:
*	a) tables selected
*	b) connection definition (if used)

* If neither a connection definition has been chosen, nor the connections enumerated,
* nor a table chosen, nor tables analyzed, bail

IF Thisform.oEngine.UserConnection = "" ;
	AND !Thisform.lTableChosen AND Thisform.oEngine.AnalyzeTablesRecalc ;
	OR EMPTY(Thisform.oEngine.SourceDB) THEN
	RETURN .T.
ENDIF

* Also, if the database name hasn't changed, we can bail
lnSelectedDB = Thisform.cSourceDatabase
IF lnSelectedDB = Thisform.oEngine.SourceDB
	RETURN .T.
ENDIF

* Prevent lostfocus event of txtText from firing
this.ReallyLostFocus =.F.
* If connection def chosen or a table has been chosen, warn the user, change if they want to
IF Thisform.lTableChosen OR !Thisform.oEngine.UserConnection = "" THEN
	lnUserInput = MESSAGEBOX("You have changed the database you are upsizing.  If you continue, the tables you chose to " + ;
							"upsize will be reset." + CHR(10) + CHR(13) + CHR(10) + CHR(13)+ ;
							"Continue?",4 + 48,ThisForm.Caption)
ELSE
	lnUserInput = 6
ENDIF	
this.ReallyLostFocus = .T.

IF lnUserInput = 6 THEN
	Thisform.AnalysisCleanup()
	RETURN .T.
ELSE
	this.lstList.value = RTRIM(this.OldListValue)
	this.cmdOpen.setfocus
	RETURN .F.
ENDIF
ENDPROC
PROCEDURE selffill
lparameters tcDatabase	&& only here because BINDEVENT requires it
LOCAL lcDBName

this.CreateDBArray
ASORT(This.aOpenDatabases)
this.lstList.rowsource = "This.Parent.aOpenDatabases"
IF This.aOpenDatabases[1] <> "<No database open>"
	lcDBName = LOWER(Thisform.oEngine.JustStem(DBC()))
	IF EMPTY(lcDBName)
		lcDBName = This.aOpenDatabases[1,1]
	ENDIF
	this.lstList.DisplayValue = lcDbName
	this.OldListValue = This.lstList.Value
ENDIF

this.SelfFilled = .T.
this.ReallyLostFocus = .T.
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
4[END RESERVED2]
[START RESERVED3]
*createdbarray 
*exclusonly 
*reallychangesourcedb 
*selffill 
^aopendatabases[1,1] 
oldlistvalue
reallylostfocus
selffilled
[END RESERVED3]
[START RESERVED4]
c:\program files\microsoft visual foxpro 9\tools\xsource\vfpsource\apps\fox30\[END RESERVED4]
[START RESERVED5]
c:\program files\microsoft visual foxpro 9\tools\xsource\vfpsource\apps\fox30\[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Choose database to upsize[END RESERVED7]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H917OC1F
[CLASS] basewizardcommandbutton
[CLASSLOC] basewizard.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdOpen
[PARENT] choosesourcedb
[START PROPERTIES]
Caption = "\<Open..."
Left = 156
Name = "cmdOpen"
Top = 15
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
LOCAL lcNameOnly, lcOld, lcMsg, lcOtherDatabase
LOCAL loException as Exception
LOCAL lnErrorNO as Integer

lcOtherDatabase = GETFILE("dbc", 'File Name:', 'OK')

IF EMPTY(lcOtherDatabase)
	RETURN
ENDIF

IF !FILE(lcOtherDatabase)
	* should not occur
	=MESSAGEBOX("File not Found")
	RETURN
ENDIF

lnErrorNO = 0

TRY
	OPEN DATABASE (lcOtherDatabase) EXCLUSIVE
CATCH TO loException
	lnErrorNO = loException.ErrorNo
ENDTRY

IF lnErrorNO > 0 THEN
	IF lnErrorNO = 1705
		lcMsg = "Cannot open exclusive " + lcOtherDatabase
	ELSE
		lcMsg = "Cannot open "  + lcOtherDatabase
	ENDIF
	=MESSAGEBOX(lcMsg,48, ThisForm.Caption)
	RETURN
ENDIF

* select current database
WITH This.parent
	.CreateDBArray()
	.lstList.Requery()
	.lstList.value = lcOtherDatabase
	.OldListValue = .lstList.Value
ENDWITH

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8O17UA0X
[CLASS] basewizardlistbox
[CLASSLOC] basewizard.vcx
[BASECLASS] listbox
[OBJNAME] lstList
[PARENT] choosesourcedb
[START PROPERTIES]
BoundColumn = 2
ControlSource = "Thisform.cSourceDatabase"
Height = 115
IntegralHeight = .F.
Name = "lstList"
RowSourceType = 5
Top = 15
Width = 133
[END PROPERTIES]
[START METHODS]
PROCEDURE DblClick
IF TYPE("ThisForm.cmdNext") = "O"
	ThisForm.cmdNext.Click()
ENDIF
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R7204KDUE
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] Wizlabel1
[PARENT] choosesourcedb
[START PROPERTIES]
Caption = "\<Database to upsize:"
Name = "Wizlabel1"
TabIndex = 1
Top = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] choosesourcedb
[START PROPERTIES]
Tahoma, 0, 8, 5, 13, 11, 21, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R02133VG8
[CLASS] basewizardcontainer
[CLASSLOC] basewizard.vcx
[BASECLASS] container
[OBJNAME] choosetargetdb
[START PROPERTIES]
</VFPData>
<memberdata name="aserverdatabases" type="property" display="aServerDatabases"/>
<memberdata name="checkdbpermissions" type="method" display="CheckDbPermissions"/>
<memberdata name="connecttotarget" type="method" display="ConnectToTarget"/>
<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
<memberdata name="isvalid" type="method" display="IsValid"/>
<memberdata name="moveforward" type="method" display="MoveForward"/>
<memberdata name="oldlen" type="property" display="OldLen"/>
<memberdata name="selffill" type="method" display="SelfFill"/>
<memberdata name="selffilled" type="property" display="SelfFilled"/>
<memberdata name="setcomp" type="method" display="SetComp"/>
Height = 87
Name = "choosetargetdb"
TabIndex = 1
Width = 280
_memberdata =      720<VFPData>
oldlen = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE checkdbpermissions
*Here checking to see the user can create tables, defaults, and sprocs

LOCAL lcErrMsg, lcSQL, lnOldArea, lnRetVal, lnRetVal, ;
	lcServerDB, aPerm, lcCRLF, llRetVal
	
lcServerDB=RTRIM(this.cboDatabases.value)
Thisform.oEngine.ServerDBName=lcServerDB
lcCRLF=CHR(10)+CHR(13)

*Set permissions to true, then flip them false as appropriate
Thisform.oEngine.Perm_Table		=	.T.
Thisform.oEngine.Perm_Default	=	.T.
Thisform.oEngine.Perm_Sproc		=	.T.
Thisform.oEngine.Perm_Index		=	.T.
Thisform.oEngine.Perm_Trigger	=	.T.

* Need special handling for SQL 7.0 and higher
IF Thisform.oEngine.ServerVer >= 7 
	IF !THIS.SetComp(lcServerDB)
		RETURN .F.
	ENDIF
ENDIF

*If the user is 'sa', bail
IF Thisform.oEngine.UserID=1 THEN
	RETURN .T.
ENDIF

*Use the target database
IF !this.ConnectToTarget() THEN
	*If the user can't even use the database, they clearly don't have much
	*in the way of permissions
	lcErrMsg=STRTRAN(CANT_CONNECT_LOC,'|1',lcServerDb)
	=MESSAGEBOX(lcErrMsg,48,TITLE_TEXT_LOC)
	RETURN .F.
ENDIF

*Get user name and id (overwrite the user name and id that came from the Master database)
lcUserName=""
lnUserID=0
lnRetVal=Thisform.oEngine.SingleValueSPT("select USER_NAME()",@lcUserName,"Exp")
Thisform.oEngine.UserName=lcUserName
lnRetVal=Thisform.oEngine.SingleValueSPT("select USER_ID()",@lnUserID,"Exp")
Thisform.oEngine.UserID=lnUserID

*Try to create a table
lcSQL="Create table __fo_1o (x char(1))"
llRetVal=Thisform.oEngine.ExecuteTempSPT(lcSQL)
IF llRetVal THEN
	*drop the table, ignore errors
	lcSQL="Drop table __fo_1o"
	=Thisform.oEngine.ExecuteTempSPT(lcSQL)
ELSE
	Thisform.oEngine.Perm_table=.F.
ENDIF

*Try to create a default
lcSQL="Create default __w_hip_6 as 'x'"
llRetVal=Thisform.oEngine.ExecuteTempSPT(lcSQL)
IF llRetVal THEN
	*drop the default
	lcSQL="Drop default __w_hip_6"
	=Thisform.oEngine.ExecuteTempSPT(lcSQL)
ELSE
	Thisform.oEngine.Perm_Default=.F.
ENDIF

*Try to create a sproc
lcSQL="Create procedure __R_W_F_ as SELECT USER_NAME()"
llRetVal=Thisform.oEngine.ExecuteTempSPT(lcSQL)
IF llRetVal THEN
	*drop the sproc
	lcSQL="Drop procedure __R_W_F_"
	=Thisform.oEngine.ExecuteTempSPT(lcSQL)
ELSE
	Thisform.oEngine.Perm_Sproc=.F.
ENDIF

lcErrMsg=""
IF !Thisform.oEngine.Perm_Table THEN
	lcErrMsg=CANT_CREATE_TABLE
ENDIF

IF !Thisform.oEngine.Perm_Default THEN
	IF !EMPTY(lcErrMsg) THEN
		IF Thisform.oEngine.Perm_Sproc THEN
			lcErrMsg=lcErrMsg+ OR_LOC
		ELSE
			lcErrMsg=lcErrMsg+ ", "
		ENDIF
	ENDIF
	lcErrMsg=lcErrMsg+CANT_CREATE_DEFAS
ENDIF

IF !Thisform.oEngine.Perm_Sproc THEN
	IF !EMPTY(lcErrMsg) THEN
		IF !Thisform.oEngine.Perm_Default and !Thisform.oEngine.Perm_Table THEN
			lcErrMsg=lcErrMsg+ ", " + OR_LOC
		ELSE
			lcErrMsg=lcErrMsg+ OR_LOC
		ENDIF
	ENDIF
	lcErrMsg=lcErrMsg+CANT_CREATE_SPROCS
ENDIF

IF !EMPTY(lcErrMsg) THEN
	lcErrMsg=STRTRAN(LACKING_PERMS_LOC,"|1",lcServerDB)+lcErrMsg + "."
	=MESSAGEBOX(lcErrMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
ENDIF

ENDPROC
PROCEDURE connecttotarget
*If the user specified a database other than "Master"
*when logging in, connect to it now

LOCAL lcServerDB, lnRetVal, lnErrNo, lcErrMsg

#DEFINE SQS_ERR_INVALUSER  		916			&&Executing incorrect SQL syntax; should only occur when creating user sprocs and defaults

IF RTRIM(LOWER(Thisform.oEngine.ServerDBName))<>"master" THEN
	
	lcServerDB=RTRIM(Thisform.oEngine.ServerDBName)
	lnRetVal=Thisform.oEngine.ExecuteTempSPT("use " + lcServerDB, @lnErrNo, @lcErrMsg)

	IF lnErrNo=SQS_ERR_INVALUSER THEN
		RETURN .F.
	ENDIF
	
ENDIF

ENDPROC
PROCEDURE isvalid
local llReturn, ;
	lcDBName, ;
	lcExact, ;
	i
This.lblDBExists.Visible = .F.
llReturn = .T.
lcDBName = alltrim(This.txtNewDatabaseName.Value)
do case
	case This.opgNewOrExisting.Value = 1

	*If there's no name, bail.  The interactive change code insures the
	*user can't go anywhere until they enter a valid name
	case empty(lcDBName)
		llReturn = .F.

	*Make sure name isn't already taken
	otherwise
		lcExact = set('EXACT')
		set exact on
		for i = 1 to alen(This.aServerDatabases, 1)
			if lower(This.aServerDatabases[i, 1]) = lower(lcDBName)
				This.lblDBExists.Caption = strtran(DUPLICATE_DBNAME_LOC, '|1', ;
					alltrim(This.txtNewDatabaseName.Value))
				This.lblDBExists.Visible = .T.
				llReturn = .F.
				exit
			endif lower(This.aServerDatabases[i, 1]) = lower(lcDBName)
		next i
		set exact &lcExact

	*see if entered name is acceptable to server
		if not Thisform.oEngine.ValidName(@lcDBName)
			This.txtNewDatabaseName.Value = lcDBName
			This.txtNewDatabaseName.SetFocus()
			llReturn = .F.
		endif not Thisform.oEngine.ValidName(@lcDBName)
endcase
Thisform.lTargetDatabaseValid = llReturn
return llReturn

ENDPROC
PROCEDURE moveforward
*If user upsizing to existing database, check their permissions
IF this.opgNewOrExisting.value<>NEW_DB THEN
	RETURN this.CheckDBPermissions()
ENDIF


ENDPROC
PROCEDURE selffill
local nRetVal, lcSQL, lnOldArea, lcExact,lnDatabaseCount

wait window 'Getting databases...' nowait


*Dis/enable based on user permission to create databases
this.opgNewOrExisting.BaseOptionButton2.enabled=Thisform.oEngine.Perm_Database

*Set option group to existing
IF !Thisform.oEngine.Perm_Database THEN
	this.opgNewOrExisting.VALUE=EXISTING
	this.opgNewOrExisting.interactivechange()
	Thisform.oEngine.CreateNewDB=.F.
***
else
	this.opgNewOrExisting.Refresh()
***
ENDIF
		
lnOldArea=SELECT()
SELECT 0
lcSQL="sp_helpdb"
nRetVal=SQLEXEC(Thisform.oEngine.MasterConnHand,lcSQL)
*user may not have permission to execute this sproc
IF nRetVal=1 THEN
	lnDatabaseCount = RECCOUNT()
	DIMENSION This.aServerDatabases[lnDatabaseCount,2]
	COPY TO ARRAY This.aServerDatabases FIELDS Name
	USE
	FOR kk = 1 TO lnDatabaseCount
		This.aServerDatabases[kk,1] = ALLTRIM(This.aServerDatabases[kk,1])
	ENDFOR
	SELECT (lnOldArea)
ELSE
	DIMENSION This.aServerDatabases[1,2]
	This.aServerDatabases[1,1]=Thisform.oEngine.ServerDBName
ENDIF

this.cboDatabases.rowsource="This.Parent.aServerDatabases"
***this.cboDatabases.value=RTRIM(Thisform.oEngine.ServerDBName)
do case
	case not empty(Thisform.cNewTargetDatabase)
		lcValue = Thisform.cNewTargetDatabase
	case not empty(Thisform.cTargetDatabase)
		lcValue = Thisform.cTargetDatabase
	otherwise
		lcValue = rtrim(Thisform.oEngine.ServerDBName)
endcase
This.cboDatabases.Value = lcValue
***
this.opgNewOrExisting.InteractiveChange()
This.Refresh()
this.SelfFilled=.T.

wait clear

ENDPROC
PROCEDURE setcomp
LPARAMETER tcDBName
LOCAL lcSQL,lnCompLevel,llRetVal,lcDBName

IF ATC("SQL Server",Thisform.oEngine.ServerType)=0
	RETURN
ENDIF

lcDBName=ALLTRIM(tcDBName)
IF LOWER(lcDBName)="master"	&&don't allow changes to SQL7 master DB
	MESSAGEBOX(NO_SQL7UPSIZEMASTER_LOC)
	RETURN .F.
endif
*** DH 07/24/2013: RETURN .T. at this point since compatibility isn't used anymore.
return .T.

lnCompLevel=0
lcSQL = "select cmptlevel from master.dbo.sysdatabases where name='"+lcDBName+"'"
llRetVal=Thisform.oEngine.SingleValueSPT(lcSQL,@lnCompLevel,"cmptlevel")

IF llRetVal AND lnCompLevel=>70
	Thisform.oEngine.nSQL7CompLevel = lnCompLevel

	* RMK - 2004/01/27 - added following to fix bug with not being able to set compatibility level when not logged in as SA
	lcSQL = [use ] + lcDBName
	llRetVal=Thisform.oEngine.ExecuteTempSPT(lcSQL)
	
    IF llRetVal
		lcSQL=[sp_dbcmptlevel ]+lcDBName+[,65]
		llRetVal=Thisform.oEngine.ExecuteTempSPT(lcSQL)
	ENDIF
	IF !llRetVal
		MESSAGEBOX(NO_SQL7BADCOMPLEVEL_LOC)
		RETURN .F.
	ENDIF
ENDIF

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
6[END RESERVED2]
[START RESERVED3]
*checkdbpermissions 
*connecttotarget 
*isvalid 
*moveforward 
*selffill 
*setcomp 
^aserverdatabases[1,1] 
oldlen
selffilled
[END RESERVED3]
[START RESERVED4]
c:\program files\microsoft visual foxpro 9\tools\xsource\vfpsource\apps\fox30\[END RESERVED4]
[START RESERVED5]
c:\program files\microsoft visual foxpro 9\tools\xsource\vfpsource\apps\fox30\[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Combo box of databases on selected server or text box for new name[END RESERVED7]
[START RESERVED8]
..\include\alldefs.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R02133V49
[CLASS] basewizardcombobox
[CLASSLOC] basewizard.vcx
[BASECLASS] combobox
[OBJNAME] cboDatabases
[PARENT] choosetargetdb
[START PROPERTIES]
ControlSource = "Thisform.cTargetDatabase"
Enabled = .F.
Name = "cboDatabases"
RowSourceType = 5
TabIndex = 3
Top = 26
Visible = .F.
Width = 133
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _15K01MZED
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] lblDBExists
[PARENT] choosetargetdb
[START PROPERTIES]
Caption = "<db name already exists message goes here>"
FontBold = .T.
ForeColor = 255,0,0
Height = 15
Name = "lblDBExists"
TabIndex = 5
Top = 59
Visible = .F.
Width = 263
WordWrap = .T.
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8M0WXBNU
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] lblDescription
[PARENT] choosetargetdb
[START PROPERTIES]
Caption = "lblDescription"
Left = 1
Name = "lblDescription"
TabIndex = 1
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
This.Caption = NEW_LBL_DESC_LOC

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R02133V52
[CLASS] basewizardoptiongroup
[CLASSLOC] basewizard.vcx
[BASECLASS] optiongroup
[OBJNAME] opgNewOrExisting
[PARENT] choosetargetdb
[START PROPERTIES]
ButtonCount = 2
ControlSource = "Thisform.nDatabaseType"
Height = 43
Left = 145
Name = "opgNewOrExisting"
TabIndex = 4
Top = 19
Width = 68
baseoptionbutton1.Caption = "E\<xisting"
baseoptionbutton1.Left = 5
baseoptionbutton1.Name = "baseoptionbutton1"
baseoptionbutton1.Top = 5
baseoptionbutton2.Caption = "Ne\<w"
baseoptionbutton2.Left = 5
baseoptionbutton2.Name = "baseoptionbutton2"
baseoptionbutton2.Top = 23
baseoptionbutton2.Value = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
LOCAL llTxtNewDatabaseName, llCboDatabases

IF this.value=EXISTING
	*If the user has already been to this step and chose new database *AND* gone
	*on to step 4 (thus creating a bunch of tables with device info), nuke that info
	IF Thisform.oEngine.DeviceRecalc=.F. THEN
		lnRetVal=MESSAGEBOX(REALLY_CHANGE_TARGET_LOC,YES_NO_BUTTONS+ICON_EXCLAMATION,TITLE_TEXT_LOC)
		IF lnRetVal = USER_YES THEN
			Thisform.oEngine.DeviceCleanUp
			Thisform.oEngine.ChooseTargetDBRecalc=.F.
			Thisform.oEngine.DataSourceChosen=.T.
			Thisform.oEngine.DeviceRecalc=.T.
		ELSE
			this.value=NEW_DB
			RETURN
		ENDIF
	ENDIF
	this.parent.txtNewDatabaseName.enabled=.F.
	this.parent.txtNewDatabaseName.visible=.F.
	this.parent.cboDatabases.enabled=(Thisform.oEngine.Userconnection=="")
	this.parent.cboDatabases.visible=.T.
	this.parent.lblDescription.caption=IIF(Thisform.oEngine.Userconnection=="", ;
		STRTRAN(EXISTING_LBL_DESC_LOC,"'|1'", ;
		iif(empty(Thisform.oEngine.DataSourceName), alltrim(Thisform.cServer), ;
		RTRIM(Thisform.oEngine.DataSourceName))), DATABASE_TXT_LOC + ":")
	Thisform.oEngine.CreateNewDB=.F.
ELSE
	this.parent.cboDatabases.enabled=.F.
	this.parent.cboDatabases.visible=.F.
	this.parent.cboDatabases.ZOrder(1)
	this.parent.txtNewDatabaseName.enabled=.T.
	this.parent.txtNewDatabaseName.visible=.T.
	this.parent.txtNewDatabaseName.ZOrder(0)
	this.parent.txtNewDatabaseName.setfocus()
	IF ALLTRIM(this.parent.txtNewDatabaseName.value)==""
		this.parent.txtNewDatabaseName.value="" && SPACE(30)
	ENDIF
	this.parent.lblDescription.caption=NEW_LBL_DESC_LOC
	Thisform.oEngine.CreateNewDB=.T.
endif
This.Parent.IsValid()
dodefault()

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1MQ1B6NM3
[CLASS] basewizardtextbox
[CLASSLOC] basewizard.vcx
[BASECLASS] textbox
[OBJNAME] txtNewDatabaseName
[PARENT] choosetargetdb
[START PROPERTIES]
ControlSource = "Thisform.cNewTargetDatabase"
Name = "txtNewDatabaseName"
TabIndex = 2
Top = 26
Width = 133
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
IF !CHRSAW() THEN
	this.parent.OldLen=LEN(ALLTRIM(this.value))
endif
This.Parent.IsValid()
dodefault()

ENDPROC
PROCEDURE LostFocus
This.Value = chrtran(This.Value, chr(13) + chr(10), '')

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] choosetargetdb
[START PROPERTIES]
Tahoma, 0, 8, 5, 13, 11, 27, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HA0V02NG
[CLASS] basewizardcontainer
[CLASSLOC] basewizard.vcx
[BASECLASS] container
[OBJNAME] ctablelist
[START PROPERTIES]
Height = 282
Name = "ctablelist"
Width = 255
cchoosefield = Export
cfieldlistalias = crsFields
ckeylistalias = 
colddbc = 
coldpath = 
crecordsourcealias = crsTables
ctablenamefield = TableName
ctruecollumnnamealias = 
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
IF !USED(This.cRecordsourcealias)
	CREATE CURSOR (This.cRecordsourcealias) (TableNum I,TableName c(250), CAClassName c(250), EXPORT L, Type C(1), TableNamePath M)
ENDIF

*!*	IF !USED(This.cFieldlistalias)
*!*		CREATE CURSOR (This.cFieldlistalias) (TableNum I, FieldNum I, FieldKey n(1), FieldUpdate n(1), ;
*!*												FieldRefresh n(1), FieldName c(250), FoxFieldName c(250), ;
*!*												FieldType c(10), FieldLen n(10), FieldDec n(10))
*!*	ENDIF

*!*	This.grdTable.RecordSource = This.cRecordsourcealias
*!*	This.grdTable.RecordSourceType = 1 && Alias
*!*	This.GrdTable.Column1.ControlSource = This.cRecordsourcealias+ ".EXPORT"
*!*	This.GrdTable.Column2.ControlSource = This.cRecordsourcealias+ ".TableName"

This.grdTable.Refresh()

This.Setfilter()

ENDPROC
PROCEDURE checkforchoosen
local laChosenCount[1], ;
	lcSQLStr
laChosenCount[1] = 0
lcSQLStr = 'select count(' + This.cChoosefield + ') from ' + ;
	This.cRecordSourceAlias + ' where ' + This.cChooseField + ;
	' into array laChosenCount'
&lcSQLStr  
return laChosenCount[1] <> 0

ENDPROC
PROCEDURE clear
LOCAL lnOldWorkArea as Integer

lnOldWorkArea  = SELECT()
IF USED(This.cRecordsourcealias)
	SELECT(This.cRecordsourcealias)
	ZAP
ENDIF
IF USED(This.cFieldlistalias)
	SELECT(This.cFieldlistalias)
	ZAP
ENDIF

SELECT(lnOldWorkArea )
ENDPROC
PROCEDURE crecordsourcealias_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method

WITH This.grdTable as Grid
	IF USED(vNewVal)
		LOCAL lcTagName, lcIndexExpr as String
		LOCAL liOldWorkArea, liCurrentTag as Integer
		
		liOldWorkArea = SELECT()
		lcTagName = ""
		liCurrentTag =1
		SELECT(m.vNewVal)
		DO WHILE !EMPTY(TAG(liCurrentTag))
			IF UPPER(TAG(liCurrentTag)) = "TBLORD"
				lcTagName = "TBLORD"
				EXIT 
			ENDIF
			liCurrentTag = liCurrentTag + 1
		ENDDO
		IF EMPTY(lcTagName)
			TRY 
				lcIndexExpr = "INDEX ON UPPER(ALLTRIM(" + This.cTablenamefield + ")) TAG TBLORD Additive"
				&lcIndexExpr.
				lcTagName = "TBLORD"
			CATCH
				lcTagName = ""
			ENDTRY
		ENDIF
		IF !EMPTY(lcTagName)
			SET ORDER TO TAG &lcTagName. ASCENDING 
		ENDIF
		SELECT(liOldWorkArea)
		.RecordSource = vNewVal
		.RecordSourceType = 1 && Alias
		.Column1.ControlSource = vNewVal + "." + This.cChoosefield
		.Column2.ControlSource = vNewVal+ "." + This.cTablenamefield
		.Column3.ControlSource = vNewVal+ ".TStampAdd"
		.Column4.ControlSource = vNewVal+ ".IdentAdd"		
	ELSE
		.RecordSource = ""
	ENDIF

	.Refresh()
ENDWITH

THIS.crecordsourcealias = m.vNewVal
ENDPROC
PROCEDURE getdbcobject
LPARAMETERS taObjects, tcType, tcDirectory

LOCAL lcTempAliasName, lcDirectory as String
LOCAL loException as Exception

EXTERNAL ARRAY taObjects

lcDirectory = ""
IF TYPE("tcDirectory") = "C"
	lcDirectory = ADDBS(ALLTRIM(tcDirectory))
ENDIF

lnObjectCount = ALEN(taObjects,1)

FOR lnCurrentObject = 1 TO lnObjectCount
	lcObjectName = UPPER(ALLTRIM(taObjects[lnCurrentObject]))

	SELECT (This.Crecordsourcealias)
	LOCATE FOR UPPER(ALLTRIM(TableName)) == lcObjectName
	IF !FOUND()
		lnTableNum = RECCOUNT(This.Crecordsourcealias)
		INSERT INTO (This.Crecordsourcealias) (TableNum ,TableName, EXPORT, Type, TableNamePath) ;
					VALUES(lnTableNum, taObjects[lnCurrentObject], .T., tcType, lcDirectory)
	
		lcTempAliasName = SYS(2015)
		TRY
			USE (lcDirectory + taObjects[lnCurrentObject]) ALIAS (lcTempAliasName) AGAIN IN 0 NODATA SHARED
		CATCH TO loException
		ENDTRY

		IF USED(lcTempAliasName)	
			This.getteblefields(lcTempAliasName, taObjects[lnCurrentObject], lnTableNum, This.cKeylistalias, This.cTruecollumnnamealias)
			USE IN (lcTempAliasName)
		ENDIF
	ENDIF
ENDFOR

ENDPROC
PROCEDURE getdbctables
LPARAMETERS tcDBCName

LOCAL lcOldDBC, laTables[1,1], laViews[1,1] as String
LOCAL lnObjectCount, lnCurrentObject, lnTableNum, lnOldWorkArea as Integer

IF !DBUSED(tcDBCName)
	IF FILE(tcDBCName)
		OPEN DATABASE (tcDBCName)
	ENDIF
ENDIF

IF !DBUSED(tcDBCName)
	RETURN .F.
ENDIF

lcOldDBC = SET("Database")
lnOldWorkArea = SELECT()
SET DATABASE TO (tcDBCName)

* Get All Tables
lnObjectCount = ADBOBJECTS(laTables,"TABLE")
IF lnObjectCount > 0
	This.GEtdbcobject(@laTables, "T")
ENDIF

* Get Alll Views
lnObjectCount = ADBOBJECTS(laTables,"VIEW")
IF lnObjectCount > 0
	This.GEtdbcobject(@laTables, "V")
ENDIF

This.cOLddbc = tcDBCName

SELECT(lnOldWorkArea)
SET DATABASE TO (lcOldDBC)
ENDPROC
PROCEDURE getteblefields
LPARAMETERS tcAlias, tcTableName, tnTableNum, tcKeys, tcTrueCollumnsName

LOCAL lnOldAlias, lnKey, lnUpdate, lcTrueFieldName

lnOldAlias = SELECT()
SELECT(tcAlias)
lnNumFileds = AFIELDS(aFileds)

IF !EMPTY(tcKeys) AND USED(tcKeys)
	SELECT * FROM (tcKeys) WHERE UPPER(ALLTRIM(Table_Name)) == UPPER(tcTableName) ;
	INTO CURSOR crsTableKeys
ENDIF

IF !EMPTY(tcTrueCollumnsName) AND USED(tcTrueCollumnsName)
	SELECT * FROM (tcTrueCollumnsName) WHERE UPPER(ALLTRIM(Table_Name)) == UPPER(tcTableName);
	INTO CURSOR crsTrueNameTableColumns
ENDIF

FOR lnCorrentField = 1 TO lnNumFileds 
	lnKey = 0
	lnUpdate = 1
	lnRefreshField = 0
	lcFieldName = aFileds[lnCorrentField,1]
	IF USED("crsTableKeys")
		SELECT crsTableKeys
		LOCATE FOR STRTRAN(ALLTRIM(UPPER(Column_Name))," ","_") == UPPER(lcFieldName)
		IF FOUND()
			lnKey = 1
		ELSE
			lnKey = 0
		ENDIF
	ELSE
		IF (VARTYPE(tcKeys) = "C" AND !EMPTY(tcKeys) AND (UPPER(lcFieldName) $ UPPER(tcKeys)))
			lnKey = 1
		ENDIF
		lnUpdate = IIF(aFileds[lnCorrentField,18] <> 0,0,1)
		lnRefreshField = IIF(!EMPTY(aFileds[lnCorrentField,9]),1,;
							IIF(aFileds[lnCorrentField,18] <> 0,1,0))
	ENDIF
	
	IF USED("crsTrueNameTableColumns")
		SELECT crsTrueNameTableColumns
		LOCATE FOR STRTRAN(ALLTRIM(UPPER(Column_Name))," ","_") == UPPER(lcFieldName)
		IF FOUND()
			lcTrueFieldName = ALLTRIM(crsTrueNameTableColumns.Column_Name)
			IF LOWER(ALLTRIM(crsTrueNameTableColumns.Type_Name)) == "int identity"
				lnUpdate = 0
				lnRefreshField = 1
			ENDIF
		ELSE
			lcTrueFieldName = lcFieldName
		ENDIF
	ELSE
		lcTrueFieldName = lcFieldName
	ENDIF

	INSERT INTO crsFields(TableNum , FieldNum , FieldKey , FieldUpdate , FieldRefresh,;
				FieldName,  FoxFieldName , FieldType , FieldLen ,;
				FieldDec );
				VALUES(tnTableNum, lnCorrentField, lnKey, lnUpdate,lnRefreshField, ;
				lcTrueFieldName, lcFieldName, aFileds[lnCorrentField,2],;
				aFileds[lnCorrentField,3], aFileds[lnCorrentField,4])
ENDFOR
RELEASE aFileds

IF USED("crsTableKeys")
	USE IN crsTableKeys
ENDIF
IF USED("crsTrueNameTableColumns")
	USE IN crsTrueNameTableColumns
ENDIF
SELECT(lnOldAlias)
ENDPROC
PROCEDURE setfilter
LOCAL lcFilterExp, lcOR as String
LOCAL lnOldWorkArea as Integer

lcOR = ""
lnOldWorkArea = SELECT()
lcFilterExp = ""

IF This.ChkTables.Value = .t.
	lcFilterExp = "Type == 'T'"
	lcOR = " or "
ENDIF
IF This.chkViews.Value = .T.
	lcFilterExp = lcFilterExp  + lcOR + "Type == 'V'"
ENDIF

SELECT(This.cRecordsourcealias)
IF EMPTY(lcFilterExp)
	lcFilterExp = "Type = 'X'"
ENDIF
SET FILTER TO &lcFilterExp
LOCATE
This.grdTable.Refresh()

SELECT(lnOldWorkArea)
ENDPROC
PROCEDURE setfreetables
LPARAMETERS tcDirectory

LOCAL laFreeTableList[1,1] as String
LOCAL lnTablesCount as Integer

IF !DIRECTORY(tcDirectory, .t.)
	RETURN .t.
ENDIF

lnTablesCount = ADIR(laFreeTableList,  ADDBS(tcDirectory) + "*.DBF")

IF lnTablesCount > 0 
	This.Getdbcobject(@laFreeTableList, "T", tcDirectory)
ENDIF
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
16[END RESERVED2]
[START RESERVED3]
*checkforchoosen 
*clear Clears the contents of a ComboBox or ListBox control.
*crecordsourcealias_assign 
*getdbcobject 
*getdbctables 
*getteblefields 
*setfilter 
*setfreetables 
cchoosefield
cfieldlistalias
ckeylistalias
colddbc
coldpath
crecordsourcealias
ctablenamefield
ctruecollumnnamealias
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1I212A2C8
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkIdentAdd
[PARENT] ctablelist
[START PROPERTIES]
Alignment = 0
Caption = "All"
Left = 195
Name = "chkIdentAdd"
ToolTipText = "Add identity column for all tables"
Top = 7
Value = .T.
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
LOCAL lnOldWorkArea, lnOldRecno as Integer

lnOldWorkArea  = SELECT()
lnOldRecno = RECNO(This.Parent.crecordsourcealias)
Replace IdentAdd WITH This.Value ALL IN (This.Parent.crecordsourcealias)

SELECT(This.Parent.crecordsourcealias)
IF RECCOUNT() >= lnOldRecno 
	GOTO lnOldRecno  
ELSE
	LOCATE
ENDIF

This.Parent.grDTABLE.Refresh()

SELECT(lnOldWorkArea )
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkTables
[PARENT] ctablelist
[START PROPERTIES]
Alignment = 0
Caption = "\<Tables"
Left = 0
Name = "chkTables"
Top = 0
Value = .T.
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
This.Parent.Setfilter()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkTStampAdd
[PARENT] ctablelist
[START PROPERTIES]
Alignment = 0
Caption = "All"
Left = 147
Name = "chkTStampAdd"
ToolTipText = "Add timestamp column for all tables"
Top = 7
Value = .T.
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
LOCAL lcOldWorkArea, lnOldRecno as Integer

lcOldWorkArea =SELECT()
lnOldRecno = RECNO(This.Parent.crecordsourcealias)
Replace TStampAdd WITH This.Value ALL IN (This.Parent.crecordsourcealias)
SELECT(This.Parent.crecordsourcealias)
IF RECCOUNT() >= lnOldRecno
	GOTO lnOldRecno
ELSE
	LOCATE
ENDIF
This.Parent.grDTABLE.Refresh()

SELECT(lcOldWorkArea)
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkViews
[PARENT] ctablelist
[START PROPERTIES]
Alignment = 0
Caption = "\<Views"
Left = 59
Name = "chkViews"
Top = 0
Value = .T.
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
This.Parent.Setfilter()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HA0VIW6T
[CLASS] basecommandbutton
[CLASSLOC] basecontrols.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdDeselectAll
[PARENT] ctablelist
[START PROPERTIES]
Caption = "Deselect \<All"
Left = 128
Name = "cmdDeselectAll"
Top = 257
Width = 85
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
LOCAL lnOldWorkArea, lnRecno as Integer

lnOldWorkArea = SELECT()
SELECT(This.Parent.cRecordsourcealias)
lnRecno = RECNO()
Replace EXPORT WITH .F. ALL IN (This.Parent.cRecordsourcealias)
IF RECCOUNT() >= lnRecno
	GO lnRecno
ENDIF
SELECT(lnOldWorkArea)
Thisform.lTableChosen = .F.
Thisform.RefreshSteps()

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] RESERVED  
[CLASS] basecommandbutton
[CLASSLOC] basecontrols.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdSelectAll
[PARENT] ctablelist
[START PROPERTIES]
Caption = "S\<elect All"
Left = 41
Name = "cmdSelectAll"
Top = 257
Width = 85
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
LOCAL lnOldWorkArea, lnRecno as Integer

lnOldWorkArea = SELECT()
SELECT(This.Parent.cRecordsourcealias)
lnRecno = RECNO()
Replace EXPORT WITH .T. ALL IN (This.Parent.cRecordsourcealias)
IF RECCOUNT() >= lnRecno
	GO lnRecno
ENDIF
SELECT(lnOldWorkArea)
Thisform.lTableChosen = This.Parent.CheckForChoosen()
Thisform.RefreshSteps()

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HA0VIW5Q
[CLASS] basegrid
[CLASSLOC] basecontrols.vcx
[BASECLASS] grid
[OBJNAME] grdTable
[PARENT] ctablelist
[START PROPERTIES]
AllowHeaderSizing = .F.
AllowRowSizing = .F.
Column1.Alignment = 2
Column1.FontName = "Tahoma"
Column1.FontSize = 8
Column1.Name = "Column1"
Column1.Sparse = .F.
Column1.Width = 19
Column2.FontName = "Tahoma"
Column2.FontSize = 8
Column2.Name = "Column2"
Column2.ReadOnly = .T.
Column2.Width = 117
Column3.Alignment = 2
Column3.FontName = "Tahoma"
Column3.FontSize = 8
Column3.Name = "Column3"
Column3.Sparse = .F.
Column3.Width = 44
Column4.Alignment = 2
Column4.FontName = "Tahoma"
Column4.FontSize = 8
Column4.Name = "Column4"
Column4.Sparse = .F.
Column4.Width = 49
ColumnCount = 4
DeleteMark = .F.
HeaderHeight = 30
Height = 224
HighlightStyle = 2
Left = 0
Name = "grdTable"
Panel = 1
RecordMark = .F.
ScrollBars = 2
SplitBar = .F.
Top = 24
Width = 255
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HA0VIW61
[CLASS] header
[BASECLASS] header
[OBJNAME] Header1
[PARENT] ctablelist.grdTable.Column1
[START PROPERTIES]
Caption = " "
FontName = "Tahoma"
FontSize = 8
Name = "Header1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HA0VIW66
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] Check1
[PARENT] ctablelist.grdTable.Column1
[START PROPERTIES]
Alignment = 2
Caption = ""
Centered = .T.
Height = 10
Left = 13
Name = "Check1"
Top = 23
Width = 10
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
local lcAlias, ;
	lcField
lcAlias = juststem(This.Parent.ControlSource)
lcField = justext(This.Parent.ControlSource)
replace (lcField) with This.Value in (lcAlias)
Thisform.lTableChosen = This.Parent.Parent.Parent.CheckForChoosen()
Thisform.RefreshSteps()

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HA0VIW6C
[CLASS] header
[BASECLASS] header
[OBJNAME] Header1
[PARENT] ctablelist.grdTable.Column2
[START PROPERTIES]
Alignment = 2
Caption = "Tables"
FontName = "Tahoma"
FontSize = 8
Name = "Header1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1HA0VIW6G
[CLASS] basetextbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] textbox
[OBJNAME] Text1
[PARENT] ctablelist.grdTable.Column2
[START PROPERTIES]
BackColor = 255,255,255
BorderStyle = 0
Enabled = .T.
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,0
Margin = 0
Name = "Text1"
ReadOnly = .T.
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1I212A2B4
[CLASS] header
[BASECLASS] header
[OBJNAME] Header1
[PARENT] ctablelist.grdTable.Column3
[START PROPERTIES]
Alignment = 2
Caption = "Time stamp"
FontName = "Tahoma"
FontSize = 8
Name = "Header1"
ToolTipText = "Add timestamp column"
WordWrap = .T.
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1I212A2B5
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] Check1
[PARENT] ctablelist.grdTable.Column3
[START PROPERTIES]
Alignment = 2
Caption = ""
Centered = .T.
FontName = "Tahoma"
FontSize = 8
Height = 17
Left = 4
Name = "Check1"
Top = 23
Width = 60
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1I212A2BE
[CLASS] header
[BASECLASS] header
[OBJNAME] Header1
[PARENT] ctablelist.grdTable.Column4
[START PROPERTIES]
Alignment = 2
Caption = "Identity Column"
FontName = "Tahoma"
FontSize = 8
Name = "Header1"
ToolTipText = "Add identity column"
WordWrap = .T.
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1I212A2BF
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] Check1
[PARENT] ctablelist.grdTable.Column4
[START PROPERTIES]
Alignment = 2
Caption = ""
Centered = .T.
FontName = "Tahoma"
FontSize = 8
Height = 10
Left = 0
Name = "Check1"
Top = 23
Width = 10
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctablelist
[START PROPERTIES]
Tahoma, 0, 8, 5, 13, 11, 21, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMUHX
[CLASS] basecontainer
[CLASSLOC] basecontrols.vcx
[BASECLASS] container
[OBJNAME] exportoptions
[START PROPERTIES]
Height = 231
Name = "exportoptions"
Width = 602
[END PROPERTIES]
[START METHODS]
PROCEDURE setoptions
LOCAL llPwdInDef

*Because setting the value of check boxes fires the click event,
*this routine will cause an infinite loop without this flag
Thisform.oEngine.RealClick=.F.

WITH This
	*Make sure color of opaque labels is right
	.Wizlabel1.BackColor = this.backcolor
	.Wizlabel2.BackColor = this.backcolor
		
	.chkRelations.value = Thisform.oEngine.ExportRelations
	.chkStructureOnly.value = Thisform.oEngine.ExportStructureOnly
	.chkReport.value = Thisform.oEngine.DoReport
	.chkRemotizeViews.value =Thisform.oEngine.ExportViewToRmt
	.chkTableToView.value = Thisform.oEngine.ExportTableToView
	.chkIndexes.value = Thisform.oEngine.ExportIndexes
	.chkDefaults.value = Thisform.oEngine.ExportDefaults
	.chkValidation.value = Thisform.oEngine.ExportValidation

	*If the user is upsizing with a connection def, it will not
	*have a password added or removed from it.  Any connections created
	*will have a password saved only if the original conn def had a pwd.


	IF !Thisform.oEngine.UserConnection=="" THEN
		Thisform.oEngine.PwdInDef=!EMPTY(DBGETPROP(Thisform.oEngine.UserConnection,"connection","password"))
	ELSE
		Thisform.oEngine.PwdInDef=.F.
	ENDIF

	IF (Thisform.oEngine.ExportViewToRmt OR Thisform.oEngine.ExportTableToView)
		IF Thisform.oEngine.UserConnection=="" 
			.chkSavePwd.enabled=.T.
			.chkSavePwd.value=Thisform.oEngine.ExportSavePwd	
		ELSE
			.chkSavePwd.enabled=.F.
			.chkSavePwd.value=Thisform.oEngine.PwdInDef
		ENDIF
	ELSE
		.chkSavePwd.enabled=.F.
		.chkSavePwd.value=.F.
	ENDIF

	Thisform.oEngine.RealClick=.T.

	*DRI check box should be enabled if Oracle or SQL '95
	IF !Thisform.oEngine.ServerType=="SQL Server" THEN
		.chkExportDRI.enabled=.T.
		.chkExportDRI.value=Thisform.oEngine.ExportDRI
	ELSE
		.chkExportDRI.enabled=.F.
		.chkExportDRI.value=.F.
	ENDIF
ENDWITH 
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
27[END RESERVED2]
[START RESERVED3]
*setoptions 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\include\alldefs.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90XW5IC
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Baselabel1
[PARENT] exportoptions
[START PROPERTIES]
BackStyle = 1
Caption = " Data upload options: "
Left = 6
Name = "Baselabel1"
Style = 3
TabIndex = 15
Top = 153
ZOrderSet = 20
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90X23EZ
[CLASS] baseshape
[CLASSLOC] basecontrols.vcx
[BASECLASS] shape
[OBJNAME] Baseshape1
[PARENT] exportoptions
[START PROPERTIES]
Height = 65
Left = 0
Name = "Baseshape1"
Style = 3
Top = 160
Width = 263
ZOrderSet = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1VC0Y7UHC
[CLASS] baseshape
[CLASSLOC] basecontrols.vcx
[BASECLASS] shape
[OBJNAME] Baseshape2
[PARENT] exportoptions
[START PROPERTIES]
Height = 65
Left = 270
Name = "Baseshape2"
Style = 3
Top = 160
Width = 325
ZOrderSet = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UJ0WTH9E
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkBlankDates
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "Upsi\<ze blank dates as NULL"
Left = 10
Name = "chkBlankDates"
TabIndex = 18
Top = 195
Value = .T.
ZOrderSet = 17
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
Thisform.oEngine.BlankDateValue = iif(This.Value, .NULL., ;
	SQL_SERVER_EMPTY_DATE_Y2K)

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1UJ0X5VMN
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkBulkInsert
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "Use \<bulk insert for fast data upload"
ControlSource = "Thisform.lUseBulkInsert"
Left = 10
Name = "chkBulkInsert"
TabIndex = 17
Top = 175
ZOrderSet = 19
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMTYG
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkDefaults
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "\<Defaults"
Left = 10
Name = "chkDefaults"
TabIndex = 4
Top = 70
ZOrderSet = 4
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
Thisform.oEngine.ExportDefaults=this.value

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMUDH
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkExportDRI
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "\<Use declarative RI"
Left = 110
Name = "chkExportDRI"
TabIndex = 7
Top = 90
ZOrderSet = 12
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
Thisform.oEngine.ExportDRI=this.value

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMU0E
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkIndexes
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "\<Indexes"
Left = 10
Name = "chkIndexes"
TabIndex = 2
Top = 50
ZOrderSet = 5
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
Thisform.oEngine.ExportIndexes=this.value

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMUHX
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkRelations
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "\<Relationships"
Left = 10
Name = "chkRelations"
TabIndex = 6
Top = 90
ZOrderSet = 7
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
Thisform.oEngine.ExportRelations=this.value

IF Thisform.oEngine.ServerType=="Oracle" OR Thisform.oEngine.ServerType=="SQL Server95" THEN
	IF !this.value THEN
		this.parent.chkExportDRI.enabled=.F.
		this.parent.chkExportDRI.value=.F.
	ELSE
		this.parent.chkExportDRI.enabled=.T.
		this.parent.chkExportDRI.value=Thisform.oEngine.ExportDRI
	ENDIF
ELSE
	this.parent.chkExportDRI.enabled=.F.
	this.parent.chkExportDRI.value=.F.
ENDIF	

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMU22
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkRemotizeViews
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "Redirec\<t views to remote data"
Left = 280
Name = "chkRemotizeViews"
TabIndex = 11
Top = 55
ZOrderSet = 6
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
Thisform.oEngine.ExportViewToRmt=this.value

Thisform.oEngine.RealClick=.F.

IF (Thisform.oEngine.ExportViewToRmt OR Thisform.oEngine.ExportTableToView)
	IF Thisform.oEngine.UserConnection=="" 
		this.parent.chkSavePwd.enabled=.T.
		this.parent.chkSavePwd.value=Thisform.oEngine.ExportSavePwd	
	ELSE
		this.parent.chkSavePwd.enabled=.F.
		this.parent.chkSavePwd.value=Thisform.oEngine.PwdInDef
	ENDIF
ELSE
	this.parent.chkSavePwd.enabled=.F.
	this.parent.chkSavePwd.value=.F.
ENDIF

Thisform.oEngine.RealClick=.T.
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1VC0Y7UHN
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkReport
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "Create upsizing re\<port"
ControlSource = "Thisform.oEngine.DoReport"
Left = 280
Name = "chkReport"
TabIndex = 19
Top = 175
ZOrderSet = 8
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMUBT
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkSavePwd
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "Save pass\<word with views"
Left = 280
Name = "chkSavePwd"
TabIndex = 13
Top = 95
ZOrderSet = 11
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
IF !Thisform.oEngine.RealClick THEN
	RETURN
ENDIF
Thisform.oEngine.ExportSavePwd=this.value
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMU7X
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkStructureOnly
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "\<Structure only, no data"
Left = 110
Name = "chkStructureOnly"
TabIndex = 5
Top = 70
ZOrderSet = 9
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
Thisform.oEngine.ExportStructureOnly=this.value

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMU9L
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkTableToView
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "Create re\<mote views on tables"
Left = 280
Name = "chkTableToView"
TabIndex = 12
Top = 75
ZOrderSet = 10
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
Thisform.oEngine.ExportTableToView=this.value

Thisform.oEngine.RealClick=.F.

IF (Thisform.oEngine.ExportViewToRmt OR Thisform.oEngine.ExportTableToView)
	IF Thisform.oEngine.UserConnection=="" 
		this.parent.chkSavePwd.enabled=.T.
		this.parent.chkSavePwd.value=Thisform.oEngine.ExportSavePwd	
	ELSE
		this.parent.chkSavePwd.enabled=.F.
		this.parent.chkSavePwd.value=Thisform.oEngine.PwdInDef
	ENDIF
ELSE
	this.parent.chkSavePwd.enabled=.F.
	this.parent.chkSavePwd.value=.F.
ENDIF

Thisform.oEngine.RealClick=.T.
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMTWS
[CLASS] basecheckbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] checkbox
[OBJNAME] chkValidation
[PARENT] exportoptions
[START PROPERTIES]
Alignment = 0
Caption = "\<Validation rules"
Left = 110
Name = "chkValidation"
TabIndex = 3
Top = 50
ZOrderSet = 3
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
Thisform.oEngine.ExportValidation=this.value

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _S7N0PHF2Y
[CLASS] basecommandbutton
[CLASSLOC] basecontrols.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdAdvanced
[PARENT] exportoptions
[START PROPERTIES]
Caption = "\<Advanced..."
Left = 520
Name = "cmdAdvanced"
TabIndex = 14
Top = 0
ZOrderSet = 15
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
local loAdvanced
loAdvanced = newobject('Advanced', 'upswiz.vcx', '', This.Parent, Thisform.oEngine)
loAdvanced.Show()

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1VC0Z4LBV
[CLASS] basewizardcommandbutton
[CLASSLOC] basewizard.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdReportDir
[PARENT] exportoptions
[START PROPERTIES]
Caption = "..."
Height = 22
Left = 565
Name = "cmdReportDir"
TabIndex = 22
Top = 195
Width = 22
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
lcFolder = getdir(Thisform.oEngine.ReportDir, '', 'Select Report Folder', 64)
if not empty(lcFolder)
	store lcFolder to Thisform.oEngine.ReportDir, This.Parent.txtReportDir.Value
endif not empty(lcFolder)

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RSE102GGU
[CLASS] basecombobox
[CLASSLOC] basecontrols.vcx
[BASECLASS] combobox
[OBJNAME] Combo1
[PARENT] exportoptions
[START PROPERTIES]
Height = 22
Left = 90
Name = "Combo1"
RowSource = "General fields override,General and memo fields override,All fields override,Default settings"
RowSourceType = 1
TabIndex = 9
Top = 115
Width = 160
ZOrderSet = 13
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
THIS.Value = THIS.List[1]
ENDPROC
PROCEDURE InteractiveChange
Thisform.oEngine.NullOverride=this.ListIndex

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1VC0Y7UHW
[CLASS] basewizardlabel
[CLASSLOC] basewizard.vcx
[BASECLASS] label
[OBJNAME] lblReportDir
[PARENT] exportoptions
[START PROPERTIES]
Caption = "\<Output folder"
Left = 280
Name = "lblReportDir"
TabIndex = 21
Top = 199
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1VC0Y7UHM
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] lblReportOptions
[PARENT] exportoptions
[START PROPERTIES]
BackStyle = 1
Caption = " Report options: "
Left = 276
Name = "lblReportOptions"
Style = 3
TabIndex = 16
Top = 153
ZOrderSet = 20
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1VC0Y7UHO
[CLASS] basewizardtextbox
[CLASSLOC] basewizard.vcx
[BASECLASS] textbox
[OBJNAME] txtReportDir
[PARENT] exportoptions
[START PROPERTIES]
ControlSource = "Thisform.oEngine.ReportDir"
Height = 22
Left = 350
Name = "txtReportDir"
TabIndex = 20
Top = 195
Width = 215
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
* Set value to itself so ProgrammaticChange fires.

This.Value = This.Value

ENDPROC
PROCEDURE ProgrammaticChange
try
	This.ToolTipText = displaypath(This.Value, 127)
catch
endtry

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _QZQ13SA7N
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Wizlabel1
[PARENT] exportoptions
[START PROPERTIES]
BackStyle = 1
Caption = " Table attributes to upsize: "
Left = 6
Name = "Wizlabel1"
Style = 3
TabIndex = 1
Top = 28
ZOrderSet = 16
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMUGJ
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Wizlabel2
[PARENT] exportoptions
[START PROPERTIES]
BackStyle = 1
Caption = " Changes to make locally: "
Left = 276
Name = "Wizlabel2"
Style = 3
TabIndex = 10
Top = 28
ZOrderSet = 18
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RSE10BNIT
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Wizlabel3
[PARENT] exportoptions
[START PROPERTIES]
Caption = "\<Null mapping:"
Left = 10
Name = "Wizlabel3"
TabIndex = 8
Top = 119
ZOrderSet = 14
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMTVO
[CLASS] baseshape
[CLASSLOC] basecontrols.vcx
[BASECLASS] shape
[OBJNAME] Wizshape1
[PARENT] exportoptions
[START PROPERTIES]
Height = 109
Left = 0
Name = "Wizshape1"
Style = 3
Top = 35
Width = 263
ZOrderSet = 1
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMTUK
[CLASS] baseshape
[CLASSLOC] basecontrols.vcx
[BASECLASS] shape
[OBJNAME] Wizshape2
[PARENT] exportoptions
[START PROPERTIES]
Height = 109
Left = 270
Name = "Wizshape2"
Style = 3
Top = 35
Width = 325
ZOrderSet = 2
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] exportoptions
[START PROPERTIES]
Tahoma, 0, 8, 5, 13, 11, 21, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U30ZZIGF
[CLASS] basecontainer
[CLASSLOC] basecontrols.vcx
[BASECLASS] container
[OBJNAME] progressbar
[START PROPERTIES]

</VFPData>
<memberdata name="completeprocess" type="method" display="CompleteProcess"/>
<memberdata name="initprocess" type="method" display="InitProcess"/>
<memberdata name="updateprocess" type="method" display="UpdateProcess"/>
Height = 65
Name = "progressbar"
Width = 399
_memberdata =      240<VFPData>
[END PROPERTIES]
[START METHODS]
PROCEDURE completeprocess
lparameters tcTask
local lcTask, ;
	lnSeconds
if pcount() = 0
	lcTask = THERMCOMPLETE_LOC
else
	lcTask = tcTask
endif pcount() = 0
This.UpdateProcess(This.oProgress.Max, lcTask)
lnSeconds = seconds() + 1
do while seconds() < lnSeconds
	*- wait a sec
enddo

ENDPROC
PROCEDURE initprocess
lparameters tcTitle, ;
	tnBasis
with This
	.lblTitle.Caption = iif(empty(tcTitle), '', tcTitle)
	.lblTask.Caption  = ''
	.oProgress.Max    = iif(empty(tnBasis), 100, tnBasis)
	.oProgress.Value  = 0
endwith

ENDPROC
PROCEDURE updateprocess
lparameters tnProgress, ;
	tcTask
if not This.Visible
	This.Visible = .T.
endif not This.Visible
This.oProgress.Value = tnProgress
if vartype(tcTask) = 'C' and not This.lblTask.Caption == tcTask
	This.lblTask.Caption = tcTask
endif vartype(tcTask) = 'C' ...

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
4[END RESERVED2]
[START RESERVED3]
*completeprocess Completes a process
*initprocess Initializes the progress bar for a process
*updateprocess Updates the progress bar for a process
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\include\upsizing.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U310EU8U
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] lblTask
[PARENT] progressbar
[START PROPERTIES]
AutoSize = .F.
Height = 15
Left = 0
Name = "lblTask"
Top = 15
Width = 395
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1H90X23EZ
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] lblTitle
[PARENT] progressbar
[START PROPERTIES]
AutoSize = .F.
Height = 15
Left = 0
Name = "lblTitle"
Top = 0
Width = 395
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U310EU8K
[CLASS] sfprogressbar
[CLASSLOC] sfprogressbar.vcx
[BASECLASS] container
[OBJNAME] oProgress
[PARENT] progressbar
[START PROPERTIES]
Left = 0
Name = "oProgress"
Top = 40
Width = 395
bars = 60
showpercentage = .T.
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] progressbar

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1TZ10EPPV
[CLASS] basewizardform
[CLASSLOC] basewizard.vcx
[BASECLASS] form
[OBJNAME] upsizingwizardform
[START PROPERTIES]

</VFPData>
<memberdata name="analysiscleanup" type="method" display="AnalysisCleanup"/>
<memberdata name="asteps" type="property" display="aSteps"/>
<memberdata name="cancel" type="method" display="Cancel"/>
<memberdata name="cconnection" type="property" display="cConnection"/>
<memberdata name="cconnectiondatabase" type="property" display="cConnectionDatabase"/>
<memberdata name="cconnstring" type="property" display="cConnString"/>
<memberdata name="ccurrhelp" type="property" display="cCurrHelp"/>
<memberdata name="ccurrhelpfile" type="property" display="cCurrHelpFile"/>
<memberdata name="cdsn" type="property" display="cDSN"/>
<memberdata name="cdsnpassword" type="property" display="cDSNPassword"/>
<memberdata name="cdsnusername" type="property" display="cDSNUserName"/>
<memberdata name="checkdestination" type="method" display="CheckDestination"/>
<memberdata name="chelpfile" type="property" display="cHelpFile" favorites="True"/>
<memberdata name="cnewtargetdatabase" type="property" display="cNewTargetDatabase"/>
<memberdata name="completeprocess" type="method" display="CompleteProcess"/>
<memberdata name="cpath" type="property" display="cPath"/>
<memberdata name="cregistrykey" type="property" display="cRegistryKey"/>
<memberdata name="cserver" type="property" display="cServer"/>
<memberdata name="cserverpassword" type="property" display="cServerPassword"/>
<memberdata name="cserverusername" type="property" display="cServerUserName"/>
<memberdata name="csourcedatabase" type="property" display="cSourceDatabase"/>
<memberdata name="ctargetdatabase" type="property" display="cTargetDatabase"/>
<memberdata name="finish" type="method" display="Finish" favorites="True"/>
<memberdata name="initprocess" type="method" display="InitProcess"/>
<memberdata name="isstepenabled" type="method" display="IsStepEnabled"/>
<memberdata name="lcancel" type="property" display="lCancel"/>
<memberdata name="lfinish" type="property" display="lFinish"/>
<memberdata name="lneedreloadfields" type="property" display="lNeedReloadFields"/>
<memberdata name="loadstepscombo" type="method" display="LoadStepsCombo"/>
<memberdata name="ltablechosen" type="property" display="lTableChosen"/>
<memberdata name="ltargetdatabasevalid" type="property" display="lTargetDatabaseValid"/>
<memberdata name="ltrustedconnection" type="property" display="lTrustedConnection"/>
<memberdata name="lusebulkinsert" type="property" display="lUseBulkInsert"/>
<memberdata name="nconnectiontype" type="property" display="nConnectionType"/>
<memberdata name="ncurrentstep" type="property" display="nCurrentStep"/>
<memberdata name="ndatabasetype" type="property" display="nDatabaseType"/>
<memberdata name="nformerstep" type="property" display="nFormerStep"/>
<memberdata name="nmaxsteps" type="property" display="nMaxSteps" favorites="True"/>
<memberdata name="nodbctype" type="property" display="nODBCType"/>
<memberdata name="oengine" type="property" display="oEngine"/>
<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
<memberdata name="restorehelp" type="method" display="RestoreHelp"/>
<memberdata name="save" type="method" display="Save"/>
<memberdata name="selectstep" type="method" display="SelectStep"/>
<memberdata name="sethelp" type="method" display="SetHelp"/>
<memberdata name="setsourcedatabase" type="method" display="SetSourceDatabase"/>
<memberdata name="setupsteps" type="method" display="SetupSteps" favorites="True"/>
<memberdata name="stepdone" type="method" display="StepDone" favorites="True"/>
<memberdata name="stepselected" type="method" display="StepSelected"/>
<memberdata name="updateprocess" type="method" display="UpdateProcess"/>
<memberdata name="validatecurrentcontrol" type="method" display="ValidateCurrentControl"/>
BorderStyle = 2
Caption = "Upsizing Wizard"
DoCreate = .T.
Height = 504
HelpContextID = 1999945411
MaxButton = .F.
MinButton = .F.
Name = "upsizingwizardform"
Width = 780
WindowType = 1
_memberdata =     3769<VFPData>
cboSteps.Height = 22
cboSteps.Left = 160
cboSteps.Name = "cboSteps"
cboSteps.Top = 20
cboSteps.Width = 600
cconnection = 
cconnectiondatabase = 
cconnstring = 
cdsn = 
cdsnpassword = 
cdsnusername = 
cmdBack.Left = 525
cmdBack.Name = "cmdBack"
cmdBack.Top = 465
cmdCancel.Left = 445
cmdCancel.Name = "cmdCancel"
cmdCancel.Top = 465
cmdFinish.Left = 685
cmdFinish.Name = "cmdFinish"
cmdFinish.Top = 465
cmdHelp.Name = "cmdHelp"
cmdHelp.Top = 465
cmdNext.Left = 605
cmdNext.Name = "cmdNext"
cmdNext.Top = 465
cnewtargetdatabase = 
cpath = 
cserver = 
cserverpassword = 
cserverusername = 
csourcedatabase = 
ctargetdatabase = 
lneedreloadfields = .F.
lsavesettings = .F.
ltablechosen = .F.
ltargetdatabasevalid = .F.
ltrustedconnection = .F.
lusebulkinsert = .T.
nconnectiontype = 2
ndatabasetype = 0
nmaxsteps = 6
nodbctype = 1
oengine = .NULL.
pgfWizard.BASEPAGE1.Name = "BASEPAGE1"
pgfWizard.Basepage2.Caption = "Basepage2"
pgfWizard.Basepage2.Name = "Basepage2"
pgfWizard.Basepage3.Caption = "Basepage3"
pgfWizard.Basepage3.Name = "Basepage3"
pgfWizard.Basepage4.Caption = "Basepage4"
pgfWizard.Basepage4.Name = "Basepage4"
pgfWizard.Basepage5.Caption = "Basepage5"
pgfWizard.Basepage5.Name = "Basepage5"
pgfWizard.Basepage6.Caption = "Basepage6"
pgfWizard.Basepage6.Name = "Basepage6"
pgfWizard.ErasePage = .T.
pgfWizard.Height = 504
pgfWizard.Name = "pgfWizard"
pgfWizard.PageCount = 6
pgfWizard.Top = 0
pgfWizard.Width = 770
shpSeparator.Name = "shpSeparator"
shpSeparator.Top = 450
shpSeparator.Width = 750
[END PROPERTIES]
[START METHODS]
PROCEDURE Load
* Open the libraries we need.

local laCallStack[1], ;
	lcProgram, ;
	llApp, ;
	lcMain, ;
	lcFFLLocation, ;
	loException as Exception, ;
	lcMessage, ;
	lcPath
dodefault()

* Load the FLL.

astackinfo(laCallStack)
lcProgram     = laCallStack[program(-1) - 1, 2]
llApp         = upper(justext(lcProgram)) = 'APP'
lcMain        = addbs(justpath(iif(llApp, lcProgram, ;
	fullpath(justpath(lcProgram) + '\..\'))))
lcFFLLocation = lcMain + 'UPSWIZ.FLL'
if file(lcFFLLocation)
	try 
		set library to (lcFFLLocation) additive
	catch to loException
		lcMessage = 'The Upsizing Wizard could not load UPSWIZ.FLL. The ' + ;
			'error message is:' + chr(13) + chr(13) + loException.Message
	endtry
else
	lcMessage = lcFFLLocation + ' cannot be located.'
endif file(lcFFLLocation)

* If we're running this as a standalone form, set the path.

if not llApp
	This.cPath = set('PATH')
	lcPath = lcMain + 'program,' + lcMain + 'data,' + lcMain + 'lib'
	set path to '&lcPath' additive
endif not llApp

* Load the procedure files.

if empty(lcMessage)
	try
		set procedure to upswzfunc, wizusz, wzengine additive
	catch to loException
		lcMessage = 'The Upsizing Wizard could not load its procedures. ' + ;
			'The error message is:' + chr(13) + chr(13) + loException.Message
	endtry
endif empty(lcMessage)
if empty(lcMessage)
	try 
		This.oEngine = createobject('UpsizeEngine')
		This.oEngine.ServerType = SQL_Server
		This.oEngine.SQLServer  = .T.
	catch to loException
		lcMessage = loException.Message
	endtry
endif empty(lcMessage)

* Display an error message and bug out if something went wrong.

if not empty(lcMessage)
	messagebox(lcMessage, 0, This.Caption)
endif not empty(lcMessage)
return empty(lcMessage)

ENDPROC
PROCEDURE analysiscleanup
with This.pgfWizard.BasePage4
	.cTableList.cRecordSourceAlias = ''
	.cFieldTypeMap.cRecordsource   = ''
endwith
This.oEngine.AnalCleanUp('Delete')
This.oEngine.SourceDB = ''

ENDPROC
PROCEDURE checkdestination
local llReturn
with This
	do case
		case .nConnectionType = 1
			llReturn = not empty(.cConnectionDatabase) and ;
				not empty(.cConnection)
		case .nODBCType = 1
			llReturn = not empty(.cDSN)
		case .nODBCType = 2
			llReturn = not empty(.cServer)
		otherwise
			llReturn = not empty(.cConnString)
	endcase
endwith
return llReturn

ENDPROC
PROCEDURE completeprocess
This.pgfWizard.BasePage6.oProgress.CompleteProcess()

ENDPROC
PROCEDURE finish
with This
	.oEngine.NormalShutdown   = .T.
	.oEngine.NotUseBulkInsert = not .lUseBulkInsert
	bindevent(.oEngine, 'InitProcess',     This, 'InitProcess')
	bindevent(.oEngine, 'UpdateProcess',   This, 'UpdateProcess')
	bindevent(.oEngine, 'CompleteProcess', This, 'CompleteProcess')
	.oEngine.ProcessOutput()
endwith
This.Release()

ENDPROC
PROCEDURE initprocess
lparameters tcTitle, tnBasis
This.pgfWizard.BasePage6.oProgress.InitProcess(tcTitle, tnBasis)

ENDPROC
PROCEDURE releasemembers
local lcPath

* Nuke the engine object.

This.oEngine = .NULL.

* Restore the path.

lcPath = This.cPath
set path to &lcPath

ENDPROC
PROCEDURE setsourcedatabase
lparameters tcDatabase
if vartype(tcDatabase) = 'C' and not empty(tcDatabase) and file(tcDatabase)
	try
		open database (tcDatabase) exclusive
		This.cSourceDatabase = tcDatabase
	catch to loException when loException.ErrorNo = 1705
		messagebox(tcDatabase + ' cannot be opened exclusively.', 48, ;
			This.Caption)
	catch to loException
		messagebox(tcDatabase + ' cannot be opened.', 48, This.Caption)
	endtry
endif vartype(tcDatabase) = 'C' ...

ENDPROC
PROCEDURE setupsteps
with This
	.aSteps[1, 1] = 'Step 1 - Select Local Database'
	.aSteps[1, 2] = 'not empty(Thisform.cSourceDatabase)'
	.aSteps[1, 4] = '.T.'

	.aSteps[2, 1] = 'Step 2 - Select Destination'
	.aSteps[2, 2] = 'Thisform.CheckDestination()'
	.aSteps[2, 4] = '.T.'

	.aSteps[3, 1] = 'Step 3 - Select Target Database'
	.aSteps[3, 2] = 'not empty(iif(Thisform.nDatabaseType = 1, ' + ;
		'Thisform.cTargetDatabase, Thisform.cNewTargetDatabase)) and ' + ;
		'Thisform.lTargetDatabaseValid'
	.aSteps[3, 4] = '.T.'

	.aSteps[4, 1] = 'Step 4 - Choose Tables and Map Field Data Types'
	.aSteps[4, 2] = 'Thisform.lTableChosen'
	.aSteps[4, 4] = '.T.'

	.aSteps[5, 1] = 'Step 5 - Set Upsizing Options'
	.aSteps[5, 2] = '.T.'
	.aSteps[5, 4] = '.T.'

	.aSteps[6, 1] = 'Step 6 - Finish'
	.aSteps[6, 2] = '.T.'
	.aSteps[6, 4] = '.T.'
endwith
dodefault()

ENDPROC
PROCEDURE stepdone
lparameters tnStep
local llReturn, ;
	lcDataBase, ;
	lnOldWorkArea, ;
	laDummy[1], ;
	lcOldConnStr, ;
	lcConnectionStr, ;
	llNewConnection
with This.pgfWizard
	llReturn = .T.
	do case

* See if the user changed databases from their original selection. If so, we
* need to reload things.

		case tnStep = 1
			lcDataBase = This.cSourceDatabase
			if not This.oEngine.SourceDB == lcDataBase
				llReturn = .BasePage1.ChooseSourceDB.ReallyChangeSourceDB()
				if llReturn
					lnOldWorkArea = select()
					This.oEngine.SourceDB = lcDataBase
					This.oEngine.AnalyzeTables()
					select (This.oEngine.EnumTablesTbl)
					replace all Type with 'T', ;
						EXPORT with not upper(alltrim(TblName)) == "UPZMSG"
					This.lNeedReloadFields = .T.
					locate
					select (lnOldWorkArea)
				endif llReturn
			endif not This.oEngine.SourceDB == lcDataBase
			if llReturn
				select TblName from (This.oEngine.EnumTablesTbl) ;
					where Type ="T" into array laDummy 
				if _tally = 0
					messagebox('There are no tables in the selected ' + ;
						'database for upsizing.', 48, Thisform.Caption)
					llReturn = .F.
				endif _tally = 0
			endif llReturn

* Once the data source has been selected, try to connect to it.

		case tnStep = 2
			lcOldConnStr    = .BasePage2.cConnStr.cOldConnStr
			lcConnectionStr = .BasePage2.cConnStr.GetConnStr()
			llNewConnection = not upper(alltrim(lcOldConnStr)) == upper(alltrim(lcConnectionStr))
			if llNewConnection
				if not empty(lcOldConnStr)
					llReturn = .BasePage2.cConnStr.LogOff()
				endif not empty(lcOldConnStr)
				llReturn = llReturn and .BasePage2.cConnStr.LogOn()
				llReturn = llReturn and .BasePage3.ChooseTargetDB.SelfFill()
			endif llNewConnection
	
* Once a target database has been chosen, ensure it's valid and handle it.

		case tnStep = 3
			if not empty(iif(Thisform.nDatabaseType = 1, ;
				Thisform.cTargetDatabase, Thisform.cNewTargetDatabase))
				if .BasePage3.ChooseTargetDB.IsValid()
					if This.oEngine.ServerType <> ORACLE_SERVER
						.BasePage3.ChooseTargetDB.MoveForward()
					endif This.oEngine.ServerType <> ORACLE_SERVER
					This.oEngine.CreateNewDB = This.nDatabaseType = 2
					if This.oEngine.CreateNewDB
						This.oEngine.ServerDBName = This.cNewTargetDatabase
					else
						This.oEngine.ServerDBName = This.cTargetDatabase
					endif This.oEngine.CreateNewDB
					.BasePage5.ExportOptions.SetOptions()
					if This.lNeedReloadFields
						lnOldWorkArea = select()
						This.oEngine.AnalyzeFields(.T.)
						.BasePage4.cTableList.cRecordSourceAlias = This.oEngine.EnumTablesTbl
						.BasePage4.cFieldTypeMap.cRecordSource   = This.oEngine.EnumFieldsTbl
						This.oEngine.ReadViews()
						This.lNeedReloadFields = .F.
						select (lnOldWorkArea)
						This.lTableChosen = .BasePage4.cTablelist.CheckForChoosen()
						This.RefreshSteps()
					endif This.lNeedReloadFields
				endif .BasePage3.ChooseTargetDB.IsValid()
			endif not empty(iif(Thisform.nDatabaseType = 1 ...

* If we're leaving step 4, flag whether a table was chosen or not.

		case tnStep = 4
			This.lTableChosen = .BasePage4.cTablelist.CheckForChoosen()
	endcase
endwith
return llReturn

ENDPROC
PROCEDURE updateprocess
lparameters tnProgress, tcTask
This.pgfWizard.BasePage6.oProgress.UpdateProcess(tnProgress, tcTask)

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
26[END RESERVED2]
[START RESERVED3]
*analysiscleanup Clean up analysis tables
*checkdestination Determines if the destination information is complete
*completeprocess Completes the progress bar for a process
*initprocess Initialize the progress bar for a process
*setsourcedatabase Sets cSourceDatabase to the specified value
*updateprocess Update the progress bar for a process
cconnection The connection to use
cconnectiondatabase The database to use for connections
cconnstring The connection string to use
cdsn The DSN to use
cdsnpassword The password to use for the DSN
cdsnusername The user name to use for the DSN
cnewtargetdatabase The name of a new database to upsize to
cpath The current path
cserver The server to use
cserverpassword The password to use for the server
cserverusername The user name to use for the server
csourcedatabase The source database to upsize
ctargetdatabase The database to upsize to
lneedreloadfields .T. if we need to reload fields because the user changed source databases
ltablechosen .T. if a table was chosen
ltargetdatabasevalid .T. if the target database is valid
ltrustedconnection .T. to use a trusted connection
lusebulkinsert .T. to use bulk insert
nconnectiontype The type of connection to use: 1 = database connection, 2 = ODBC
ndatabasetype The database to upsize to: 1 = existing, 2 = new
nodbctype The type of ODBC connection to use: 1 = DSN, 2 = server information, 3 = connection string
oengine A reference to an UpsizeEngine object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\include\upsizing.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1TZ10ZLE6
[CLASS] choosesourcedb
[CLASSLOC] upswiz.vcx
[BASECLASS] container
[OBJNAME] ChooseSourceDB
[PARENT] upsizingwizardform.pgfWizard.BASEPAGE1
[START PROPERTIES]
CMDOPEN.Name = "CMDOPEN"
LSTLIST.Name = "LSTLIST"
Left = 160
Name = "ChooseSourceDB"
Top = 95
WIZLABEL1.Name = "WIZLABEL1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R02133VG8
[CLASS] baseimage
[CLASSLOC] basecontrols.vcx
[BASECLASS] image
[OBJNAME] Image1
[PARENT] upsizingwizardform.pgfWizard.BASEPAGE1
[START PROPERTIES]
Height = 124
Left = 10
Name = "Image1"
Picture = ..\bitmap\upsize1.bmp
Top = 20
Width = 139
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1TZ10ZLF0
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Label3
[PARENT] upsizingwizardform.pgfWizard.BASEPAGE1
[START PROPERTIES]
Caption = "Which local database do you want to upsize?"
Height = 15
Left = 160
Name = "Label3"
Top = 50
Width = 217
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1TZ10ZLF1
[CLASS] cconnstr
[CLASSLOC] upswiz.vcx
[BASECLASS] container
[OBJNAME] Cconnstr
[PARENT] upsizingwizardform.pgfWizard.Basepage2
[START PROPERTIES]
CHKUSETC.Alignment = 0
CHKUSETC.Name = "CHKUSETC"
CMBCONNECTIONS.Name = "CMBCONNECTIONS"
CMBDSN.Name = "CMBDSN"
CMBSERVERS.Name = "CMBSERVERS"
CMDGETDBC.Name = "CMDGETDBC"
EDTDATABASE.Name = "EDTDATABASE"
EDTUSERCONNSTR.Name = "EDTUSERCONNSTR"
LBLCONNECTIONS.Name = "LBLCONNECTIONS"
LBLDSN.Name = "LBLDSN"
LBLDSNPASSWORD.Name = "LBLDSNPASSWORD"
LBLDSNUSERNAME.Name = "LBLDSNUSERNAME"
LBLSERVERPWD.Name = "LBLSERVERPWD"
LBLSERVERS.Name = "LBLSERVERS"
LBLSERVERUID.Name = "LBLSERVERUID"
Left = 160
Name = "Cconnstr"
OPGCONNECTION.Name = "OPGCONNECTION"
OPGCONNECTION.baseoptionbutton1.Left = 5
OPGCONNECTION.baseoptionbutton1.Name = "baseoptionbutton1"
OPGCONNECTION.baseoptionbutton1.Top = 5
OPGCONNECTION.baseoptionbutton2.Left = 5
OPGCONNECTION.baseoptionbutton2.Name = "baseoptionbutton2"
OPGCONNECTION.baseoptionbutton2.Top = 80
OPGODBCTYPE.Baseoptionbutton3.Left = 5
OPGODBCTYPE.Baseoptionbutton3.Name = "Baseoptionbutton3"
OPGODBCTYPE.Baseoptionbutton3.Top = 164
OPGODBCTYPE.Name = "OPGODBCTYPE"
OPGODBCTYPE.baseoptionbutton1.Left = 5
OPGODBCTYPE.baseoptionbutton1.Name = "baseoptionbutton1"
OPGODBCTYPE.baseoptionbutton1.Top = 4
OPGODBCTYPE.baseoptionbutton2.Left = 5
OPGODBCTYPE.baseoptionbutton2.Name = "baseoptionbutton2"
OPGODBCTYPE.baseoptionbutton2.Top = 59
TXTDSNPASSWORD.Name = "TXTDSNPASSWORD"
TXTDSNUSERNAME.Name = "TXTDSNUSERNAME"
TXTSERVERPWD.Name = "TXTSERVERPWD"
TXTSERVERUID.Name = "TXTSERVERUID"
Top = 65
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00NRI78
[CLASS] baseimage
[CLASSLOC] basecontrols.vcx
[BASECLASS] image
[OBJNAME] Image1
[PARENT] upsizingwizardform.pgfWizard.Basepage2
[START PROPERTIES]
Height = 124
Left = 10
Name = "Image1"
Picture = ..\bitmap\upsize23.bmp
Top = 20
Width = 139
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1TZ10ZLG4
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Label9
[PARENT] upsizingwizardform.pgfWizard.Basepage2
[START PROPERTIES]
Caption = "Which data source do you want to upsize your database to?"
Left = 160
Name = "Label9"
Top = 50
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00QM774
[CLASS] choosetargetdb
[CLASSLOC] upswiz.vcx
[BASECLASS] container
[OBJNAME] Choosetargetdb
[PARENT] upsizingwizardform.pgfWizard.Basepage3
[START PROPERTIES]
Left = 160
Name = "Choosetargetdb"
Top = 100
cboDatabases.Name = "cboDatabases"
cboDatabases.ZOrderSet = 0
lblDBExists.Name = "lblDBExists"
lblDBExists.ZOrderSet = 3
lblDescription.Name = "lblDescription"
lblDescription.ZOrderSet = 2
opgNewOrExisting.Name = "opgNewOrExisting"
opgNewOrExisting.ZOrderSet = 1
opgNewOrExisting.baseoptionbutton1.Left = 5
opgNewOrExisting.baseoptionbutton1.Name = "baseoptionbutton1"
opgNewOrExisting.baseoptionbutton1.Top = 5
opgNewOrExisting.baseoptionbutton2.Left = 5
opgNewOrExisting.baseoptionbutton2.Name = "baseoptionbutton2"
opgNewOrExisting.baseoptionbutton2.Top = 23
txtNewDatabaseName.Name = "txtNewDatabaseName"
txtNewDatabaseName.ZOrderSet = 4
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _R8H1AMUHX
[CLASS] baseimage
[CLASSLOC] basecontrols.vcx
[BASECLASS] image
[OBJNAME] Image1
[PARENT] upsizingwizardform.pgfWizard.Basepage3
[START PROPERTIES]
Height = 124
Left = 10
Name = "Image1"
Picture = ..\bitmap\upsize45.bmp
Top = 20
Width = 139
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00QM77F
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Label2
[PARENT] upsizingwizardform.pgfWizard.Basepage3
[START PROPERTIES]
Caption = "Select a database on the remote server that you want to upsize to, or click New and name the new database."
Left = 160
Name = "Label2"
Top = 50
Width = 530
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00YNG5W
[CLASS] cfieldtypemap
[CLASSLOC] upswiz.vcx
[BASECLASS] container
[OBJNAME] Cfieldtypemap
[PARENT] upsizingwizardform.pgfWizard.Basepage4
[START PROPERTIES]
Left = 300
Name = "Cfieldtypemap"
Top = 170
cmdReset.Name = "cmdReset"
grdTypeMap.Name = "grdTypeMap"
grdTypeMap.grcFldName.Header1.Name = "Header1"
grdTypeMap.grcFldName.Name = "grcFldName"
grdTypeMap.grcRmtLength.Header1.Name = "Header1"
grdTypeMap.grcRmtLength.Name = "grcRmtLength"
grdTypeMap.grcRmtLength.txtLength.Name = "txtLength"
grdTypeMap.grcRmtNull.Check1.Alignment = 0
grdTypeMap.grcRmtNull.Check1.Name = "Check1"
grdTypeMap.grcRmtNull.Header1.Name = "Header1"
grdTypeMap.grcRmtNull.Name = "grcRmtNull"
grdTypeMap.grcRmtPrec.Header1.Name = "Header1"
grdTypeMap.grcRmtPrec.Name = "grcRmtPrec"
grdTypeMap.grcRmtPrec.txtPrecision.Name = "txtPrecision"
grdTypeMap.grcRmtType.Header1.Name = "Header1"
grdTypeMap.grcRmtType.Name = "grcRmtType"
grdTypeMap.grcRmtType.cboDataTypes.Name = "cboDataTypes"
grdTypeMap.grcType.Header1.Name = "Header1"
grdTypeMap.grcType.Name = "grcType"
[END PROPERTIES]
[START METHODS]
PROCEDURE grdTypeMap.grcRmtLength.txtLength.LostFocus
This.Value = CHRTRAN(This.Value, CHR(13) + CHR(10) , "")
ENDPROC
PROCEDURE grdTypeMap.grcRmtPrec.txtPrecision.LostFocus
This.Value = CHRTRAN(This.Value, CHR(13) + CHR(10) , "")
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00YNG67
[CLASS] basetextbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] textbox
[OBJNAME] Basetextbox1
[PARENT] upsizingwizardform.pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcFldName
[START PROPERTIES]
Name = "Basetextbox1"
[END PROPERTIES]
[START METHODS]
PROCEDURE LostFocus
This.Value = CHRTRAN(This.Value, CHR(13) + CHR(10) , "")
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00YNG66
[CLASS] textbox
[BASECLASS] textbox
[OBJNAME] Text1
[PARENT] upsizingwizardform.pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcFldName
[START PROPERTIES]
BackColor = 255,255,255
BorderStyle = 0
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,0
Margin = 0
Name = "Text1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00YNG6H
[CLASS] basetextbox
[CLASSLOC] basecontrols.vcx
[BASECLASS] textbox
[OBJNAME] Basetextbox1
[PARENT] upsizingwizardform.pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcType
[START PROPERTIES]
Name = "Basetextbox1"
[END PROPERTIES]
[START METHODS]
PROCEDURE LostFocus
This.Value = CHRTRAN(This.Value, CHR(13) + CHR(10) , "")
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00YNG6G
[CLASS] textbox
[BASECLASS] textbox
[OBJNAME] Text1
[PARENT] upsizingwizardform.pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcType
[START PROPERTIES]
BackColor = 255,255,255
BorderStyle = 0
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,0
Margin = 0
Name = "Text1"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00Y3O26
[CLASS] ctablelist
[CLASSLOC] upswiz.vcx
[BASECLASS] container
[OBJNAME] cTableList
[PARENT] upsizingwizardform.pgfWizard.Basepage4
[START PROPERTIES]
Left = 10
Name = "cTableList"
Top = 155
chkIdentAdd.Alignment = 0
chkIdentAdd.Name = "chkIdentAdd"
chkTStampAdd.Alignment = 0
chkTStampAdd.Name = "chkTStampAdd"
chkTables.Alignment = 0
chkTables.Name = "chkTables"
chkViews.Alignment = 0
chkViews.Name = "chkViews"
cmdDeselectAll.Name = "cmdDeselectAll"
cmdSelectAll.Name = "cmdSelectAll"
ctablenamefield = TblName
grdTable.COLUMN3.Check1.Alignment = 2
grdTable.COLUMN3.Check1.Name = "Check1"
grdTable.COLUMN3.Header1.Name = "Header1"
grdTable.COLUMN3.Name = "COLUMN3"
grdTable.COLUMN4.Check1.Alignment = 2
grdTable.COLUMN4.Check1.Name = "Check1"
grdTable.COLUMN4.Header1.Name = "Header1"
grdTable.COLUMN4.Name = "COLUMN4"
grdTable.Column1.Check1.Alignment = 2
grdTable.Column1.Check1.Name = "Check1"
grdTable.Column1.Header1.Name = "Header1"
grdTable.Column1.Name = "Column1"
grdTable.Column2.Header1.Name = "Header1"
grdTable.Column2.Name = "Column2"
grdTable.Column2.Text1.Name = "Text1"
grdTable.Name = "grdTable"
[END PROPERTIES]
[START METHODS]
PROCEDURE grdTable.AfterRowColChange
LPARAMETERS nColIndex

LOCAL m.lnOldWorkArea as Integer

m.lnOldWorkArea = SELECT()

WITH This.Parent.Parent.cFieldTypeMap
	IF !EMPTY(.grdTypeMap.RecordSource) AND USED(.grdTypeMap.RecordSource)
		SELECT(.grdTypeMap.RecordSource)
		LOCATE
	ENDIF

	.grdTypeMap.Refresh()
ENDWITH 

SELECT(m.lnOldWorkArea)
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00Y3O25
[CLASS] baseimage
[CLASSLOC] basecontrols.vcx
[BASECLASS] image
[OBJNAME] Image1
[PARENT] upsizingwizardform.pgfWizard.Basepage4
[START PROPERTIES]
Height = 124
Left = 10
Name = "Image1"
Picture = ..\bitmap\upsize45.bmp
Top = 20
Width = 139
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00Y5SJN
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Label1
[PARENT] upsizingwizardform.pgfWizard.Basepage4
[START PROPERTIES]
Caption = "Do you want to change the default mapping from local data types to server data types?"
Left = 300
Name = "Label1"
Top = 152
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00Y3O39
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Label2
[PARENT] upsizingwizardform.pgfWizard.Basepage4
[START PROPERTIES]
Caption = "Which tables do you want to upsize to the target database?"
Left = 160
Name = "Label2"
Top = 50
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00ZUTWZ
[CLASS] exportoptions
[CLASSLOC] upswiz.vcx
[BASECLASS] container
[OBJNAME] ExportOptions
[PARENT] upsizingwizardform.pgfWizard.Basepage5
[START PROPERTIES]
Baselabel1.Name = "Baselabel1"
Baseshape1.Name = "Baseshape1"
Baseshape2.Name = "Baseshape2"
Combo1.Name = "Combo1"
Left = 160
Name = "ExportOptions"
TabIndex = 4
Top = 80
Wizlabel1.Name = "Wizlabel1"
Wizlabel2.Name = "Wizlabel2"
Wizlabel3.Name = "Wizlabel3"
Wizshape1.Name = "Wizshape1"
Wizshape2.Name = "Wizshape2"
ZOrderSet = 1
chkBlankDates.Alignment = 0
chkBlankDates.Name = "chkBlankDates"
chkBulkInsert.Alignment = 0
chkBulkInsert.Name = "chkBulkInsert"
chkDefaults.Alignment = 0
chkDefaults.Name = "chkDefaults"
chkExportDRI.Alignment = 0
chkExportDRI.Name = "chkExportDRI"
chkIndexes.Alignment = 0
chkIndexes.Name = "chkIndexes"
chkRelations.Alignment = 0
chkRelations.Name = "chkRelations"
chkRemotizeViews.Alignment = 0
chkRemotizeViews.Name = "chkRemotizeViews"
chkReport.Alignment = 0
chkReport.Name = "chkReport"
chkSavePwd.Alignment = 0
chkSavePwd.Name = "chkSavePwd"
chkStructureOnly.Alignment = 0
chkStructureOnly.Name = "chkStructureOnly"
chkTableToView.Alignment = 0
chkTableToView.Name = "chkTableToView"
chkValidation.Alignment = 0
chkValidation.Name = "chkValidation"
cmdAdvanced.Name = "cmdAdvanced"
cmdReportDir.Name = "cmdReportDir"
lblReportDir.Name = "lblReportDir"
lblReportOptions.Name = "lblReportOptions"
txtReportDir.Name = "txtReportDir"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00ZUTX9
[CLASS] baseimage
[CLASSLOC] basecontrols.vcx
[BASECLASS] image
[OBJNAME] Image1
[PARENT] upsizingwizardform.pgfWizard.Basepage5
[START PROPERTIES]
Height = 124
Left = 10
Name = "Image1"
Picture = ..\bitmap\upsize9.bmp
Top = 20
Width = 139
ZOrderSet = 2
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U00ZUTZR
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Label1
[PARENT] upsizingwizardform.pgfWizard.Basepage5
[START PROPERTIES]
Caption = "Which upsizing options do you want to set?"
Left = 160
Name = "Label1"
TabIndex = 3
Top = 50
ZOrderSet = 3
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U011GNMN
[CLASS] baseimage
[CLASSLOC] basecontrols.vcx
[BASECLASS] image
[OBJNAME] Image1
[PARENT] upsizingwizardform.pgfWizard.Basepage6
[START PROPERTIES]
Height = 161
Left = 10
Name = "Image1"
Picture = ..\bitmap\flag.bmp
Top = 20
Width = 105
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U011GNMW
[CLASS] baselabel
[CLASSLOC] basecontrols.vcx
[BASECLASS] label
[OBJNAME] Label2
[PARENT] upsizingwizardform.pgfWizard.Basepage6
[START PROPERTIES]
Caption = "You are ready to upsize your data. Select an option and click Finish."
Left = 160
Name = "Label2"
TabIndex = 1
Top = 50
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U011GNMM
[CLASS] baseoptiongroup
[CLASSLOC] basecontrols.vcx
[BASECLASS] optiongroup
[OBJNAME] opgOutputType
[PARENT] upsizingwizardform.pgfWizard.Basepage6
[START PROPERTIES]
Baseoptionbutton3.Caption = "Upsize \<and save generated SQL"
Baseoptionbutton3.Left = 5
Baseoptionbutton3.Name = "Baseoptionbutton3"
Baseoptionbutton3.Top = 40
ButtonCount = 3
Height = 61
Left = 160
Name = "opgOutputType"
TabIndex = 2
Top = 70
Value = 1
Width = 183
baseoptionbutton1.Caption = "\<Upsize"
baseoptionbutton1.Left = 5
baseoptionbutton1.Name = "baseoptionbutton1"
baseoptionbutton1.Top = 5
baseoptionbutton1.Value = 1
baseoptionbutton2.Caption = "\<Save generated SQL"
baseoptionbutton2.Left = 5
baseoptionbutton2.Name = "baseoptionbutton2"
baseoptionbutton2.Top = 23
[END PROPERTIES]
[START METHODS]
PROCEDURE InteractiveChange
do case
	case This.Value = 1
		Thisform.oEngine.DoUpsize  = .T.
		Thisform.oEngine.DoScripts = .F.
	case This.Value = 2
		Thisform.oEngine.DoUpsize  = .F.
		Thisform.oEngine.DoScripts = .T.
	case This.Value = 3
		Thisform.oEngine.DoUpsize  = .T.
		Thisform.oEngine.DoScripts = .T.
endcase

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U310LQ6Q
[CLASS] progressbar
[CLASSLOC] upswiz.vcx
[BASECLASS] container
[OBJNAME] oProgress
[PARENT] upsizingwizardform.pgfWizard.Basepage6
[START PROPERTIES]
LBLTITLE.Name = "LBLTITLE"
Left = 168
Name = "oProgress"
TabIndex = 6
Top = 190
Visible = .F.
lblTask.Name = "lblTask"
oProgress.Name = "oProgress"
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] upsizingwizardform
[START PROPERTIES]
Tahoma, 0, 8, 5, 13, 11, 21, 2, 0
[END PROPERTIES]
[EOF]
